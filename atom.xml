<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>actionou.github.io</title>
  
  
  <link href="https://actionou.github.io/atom.xml" rel="self"/>
  
  <link href="https://actionou.github.io/"/>
  <updated>2020-12-02T16:34:11.516Z</updated>
  <id>https://actionou.github.io/</id>
  
  <author>
    <name>actionou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何用数据分析思维解决实际问题？</title>
    <link href="https://actionou.github.io/2020/04/02/use-data-analysis-solve-practical-problems/"/>
    <id>https://actionou.github.io/2020/04/02/use-data-analysis-solve-practical-problems/</id>
    <published>2020-04-02T15:36:17.000Z</published>
    <updated>2020-12-02T16:34:11.516Z</updated>
    
    <content type="html"><![CDATA[<p>用户分析是电商数据分析中重要的模块，在对用户特征深度理解和用户需求充分挖掘基础上，进行全生命周期的运营管理（拉新—&gt;活跃—&gt;留存—&gt;价值提升—&gt;忠诚），请尝试回答以下3个问题：</p><p>① 用户第一单购买的行为往往反映了用户对平台的信任度和消费能力。现在数据库中有一张用户交易表order，其中有userid（用户ID）、amount（消费金额）、paytime（支付时间），请写出对应的SQL语句，查出每个用户第一单的消费金额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查出每个用户第一单的消费金额</span></span><br><span class="line"><span class="comment">--使用窗口函数(考虑一个用户不能同时下两单)</span></span><br><span class="line"><span class="keyword">select</span> a.userid,a.amount</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> * ,<span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> paytime) <span class="keyword">as</span> paytime_rank <span class="keyword">from</span> <span class="keyword">order</span> ) <span class="keyword">as</span> </span><br><span class="line">a <span class="keyword">where</span> paytime_rank=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--使用联结方法</span></span><br><span class="line"><span class="comment">--查出第一单消费时间</span></span><br><span class="line">creat <span class="keyword">view</span> t <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> userid, <span class="keyword">min</span>(paytime) <span class="keyword">as</span> 首次消费时间 <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">group</span> <span class="keyword">by</span> userid)</span><br><span class="line"><span class="comment">--找出第一消费金额</span></span><br><span class="line"><span class="keyword">select</span> t.userid,t.首次消费时间 ,b.amount <span class="keyword">from</span> t <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> (t.userid=b.userid <span class="keyword">and</span> t.首次消费时间=b.paytime)</span><br></pre></td></tr></table></figure><p>② 当你发现本月的支付用户数环比上月大幅下跌（超30%），你会如何去探查背后的原因？请描述你的思路和其中涉及的关键指标。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_a372e778e2bcf40c99f03c37d16a74ed.png" alt="image.png"></p><p><strong>第一步：明确问题</strong></p><ul><li>明确数据<strong>来源和准确性</strong>：时间是本月，对比的基准是上月，地点是哪个城市的支付用户还是所有的支付用户?数据来源哪个部门，数据是否无误，</li><li><strong>业务指标</strong>理解：支付用户数=用户数*转化率 。明确是和上月对比下跌超过30%，运用多维度拆解分析方法，把整体拆成部分，查看内部的差异。</li></ul><p><strong>第二步：分析原因</strong></p><p>使用多维度拆解分析方法对支付用户数这个指标进行拆解：<strong>支付用户数=用户数*转化率</strong></p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_067cba2f944a054de9def4e0cbca28f8.png" alt="image.png"></p><p>从<strong>新老用户维度进行拆解</strong>，把用户数拆解成新用户数和老用户活跃人数，其中新用户数在平台购买过的用户人数，老用户活跃人数是在平台购买过的用户在平台活跃的人数。</p><p>新用户数按渠道维度，又继续拆解为渠道A新用户，渠道B新用户等，考虑不同渠道的转化率也可能不一样，同样分渠道拆解为渠道A转化率，渠道B转化率，渠道C转化率。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_304cdfc65cd9e493916d35565e9ac08f.png" alt="image.png"></p><p>对以上分析 做出<strong>假设一：渠道A、B、C新用户人数减少</strong></p><p>收集证据，分析渠道投放效果。使用<strong>对比分析方法</strong>，如果确认某渠道用户相比上月确实降低则对渠道用户数进行多维度拆解，可以<strong>从年龄构成拆分，性别构成拆分，职业结构拆分和地域组成拆分，分别进行假设检验</strong>，手机证据，将渠道人数降低定位到是那个人群用户数降低，渠道的导入量降低的原因，分析渠道投放是否有效。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_8fd68f327d7b122f4a458b54f6a9daef.png" alt="image.png"></p><p>继续考虑用户数 <strong>假设二：渠道A、B、C转化率降低</strong></p><p>使用对比分析如果确认某渠道转化率降低，继续按业务流程对该渠道具体哪一步出现的问题进行拆解，假设平台用户的流程有广告、进店、选择商品、购买。</p><p>则按业务流程拆解如下，通过<strong>假设检验</strong>，收集数据，查看产品板块是否更新，询问客服是否有投诉，有页面崩溃，不能成功下单导致某一环节流失率高，闪退，使用漏斗模型，判断是哪个产品环节出了问题。<strong>使用假设检验，验证每个环节的假设。</strong></p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_dc66f68108cf68059da2b219e9f2be9b.png" alt="image.png"></p><p><strong>假设三：老用户活跃人数出了问题</strong></p><p>通过假设检验和对比分析方法分析老用户活跃人数是否降低，如果降低的话，思考老用户活跃人数为什么会降低呢？我们从<strong>用户、产品、竞品</strong>三个维度分析原因。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_c2daaa1ed112a705864456766d7f9f8c.png" alt="image.png"></p><p><strong>1.</strong> 用户购买体验不好，产品描述与实际不符</p><p><strong>2.</strong> 产品售后服务不够好等</p><p><strong>3.</strong> 上月做活动，上月活跃人数大幅上涨等</p><p><strong>4.</strong> 竞品在搞活动，用户被对手吸引</p><p>可以分别从几个假设去分析原因,如果以上三大部分假设有问题，总结原因如下：</p><ul><li><strong>原始渠道A用户发生改变，</strong>导致渠道导入量下降，具体表现20-35岁年龄段人数下降，该35-50人群年龄段占比上升，而20-30岁群体是为我们平台的主要使用人群。</li><li><strong>产品更新迭代，</strong>用户习惯之前的界面，还没有适应</li><li><strong>由于之前平台大促</strong>，导致平台的售后和产品质量方面波动较大，用户颇为不满</li></ul><p>总结<strong>新用户引入不够，老用户留存没做好，产品本身改动，</strong>导致出现了这种大幅下跌的情况。</p><p><strong>第三步：提出建议</strong></p><p>针对以上的分析提出以下建议：</p><ul><li><strong>渠道A用户人群转移</strong>，考虑撤回渠道投放或者修改投放内容，吸引35-50岁人群用户进入平台，提高转化</li><li>用户使用体验不佳，建议<strong>对部分用户推更新版本</strong>，建立对照组，进行AB测试</li><li><strong>从平台的评论，对于中差评老用户进行回访</strong>，明确原因，进行挽回。</li></ul><p>③ 为了更好的理解用户，我们通常会基于用户的特征对用户进行分类，便于更加精细化的理解用户，设计产品和运营玩法，请你设计对应的聚类方法，包括重点的用户特征的选择及聚类算法并说明其基本原理和步骤。</p><p><strong>1. K-means聚类</strong></p><p>使用K-means聚类的好处是可以加入性别，地域，薪资等特征，这样就可以得到的分类的年龄分布情况，薪资情况，职业分布等情况，<strong>比RFM会信息更多，但类别的解释性没有RFM用户分层强</strong></p><p><strong>特征选择</strong>：人口统计学特征（性别，地域 ,年龄，薪资，职业，家庭成员)，用户分层特征（消费频率，平均消费金额，最近一次消费时间）产品特征(购买物品类别)</p><p><strong>基本原理</strong>：</p><p>step1：选举K个对象作为初始的聚类中心；</p><p>step2：计算每个对象与各种子聚类中心间的欧式距离，把每个对象分配给他最近的聚类中心；</p><p>step3：一旦全部对象被分配了，每个聚类的聚类中心会根据聚类中现有的对象被重新计算，重新分配。依次循环，直到聚类中心点不再改变时循环结束。</p><p><strong>2. RFM分层</strong></p><p>根据业务需求，使用RFM对用户进行分层，使用RFM的好处是<strong>得到的类别结果具有更明确的实际业务意义</strong>，能指导精细化运营。<strong>缺点是没有考虑用户的人口统计学特征。</strong></p><p>主要得到分层结果重要（一般）价值、发展、挽留、保持客户八类</p><p>step1：计算RFM值（消费频率，平均消费金额，最近一次消费时间）</p><p>step2：分别RFM进行打分，确定打分体系，按价值打分,，计算均值或中值,超过均值/中值则该项指标分类为高，低于均值则该指标分类为低，</p><p>step3：进行用户分类，根据用户分类规则找到是否高低</p><p>step4：对应表格找到用户属于哪个分类</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_3ae8a7ebdb35ad2d8c28bd147af542e7.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用户分析是电商数据分析中重要的模块，在对用户特征深度理解和用户需求充分挖掘基础上，进行全生命周期的运营管理（拉新—&amp;gt;活跃—&amp;gt;留存—&amp;gt;价值提升—&amp;gt;忠诚），请尝试回答以下3个问题：&lt;/p&gt;
&lt;p&gt;① 用户第一单购买的行为往往反映了用户对平台的信任度和消费</summary>
      
    
    
    
    
    <category term="python" scheme="https://actionou.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>玩转Pandas数据处理</title>
    <link href="https://actionou.github.io/2020/03/03/python-pandas/"/>
    <id>https://actionou.github.io/2020/03/03/python-pandas/</id>
    <published>2020-03-02T16:32:22.000Z</published>
    <updated>2020-12-02T16:42:01.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、基本处理"><a href="#1、基本处理" class="headerlink" title="1、基本处理"></a>1、基本处理</h2><ul><li>map仅能处理单列</li><li>apply能处理单列或多列，如果直接对df.apply(func,axis=1),那么传入函数的是df,df[‘price’].apply(np.log)传入的是price列</li><li>applymap对全部元素操作，df.applymap(lambda x:”%.2f” % x)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分组后直接apply，传入的是每个组的df</span></span><br><span class="line">arpu =date_buy_3.groupby(<span class="string">&#x27;date&#x27;</span>).apply(<span class="keyword">lambda</span> x:x[x.behavior_type==<span class="number">4</span>].total.<span class="built_in">sum</span>()/<span class="built_in">len</span>(x.user_id.unique()))</span><br><span class="line"></span><br><span class="line">df.info() <span class="comment"># 获取df的摘要，包括Index范围，所有列名，每一列非空值的数量及数据类型</span></span><br><span class="line">df[<span class="string">&#x27;len_str&#x27;</span>] = df[<span class="string">&#x27;grammer&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x)) <span class="comment"># 求每个字符串的长度</span></span><br><span class="line"></span><br><span class="line">df.describe() <span class="comment"># 观察这一系列数据的范围,只对可以运算的列有效。大小、波动趋势等等，便于判断后续对数据采取哪类模型更合适</span></span><br><span class="line"><span class="comment"># 包含计数，平均值，标准差，最小值，最大值，25%，50%，75%分位的数值</span></span><br><span class="line"></span><br><span class="line">df.set_index(<span class="string">&quot;A&quot;</span>) <span class="comment"># 设置A列为索引</span></span><br><span class="line">df[[<span class="string">&#x27;ID&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]].astype(<span class="built_in">float</span>) <span class="comment"># 强制类型转换</span></span><br><span class="line">df[<span class="string">&#x27;price&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;price&#x27;</span>]) <span class="comment"># 将某列转换成数值类型</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>] = df[<span class="string">&#x27;A&#x27;</span>]+df[<span class="string">&#x27;C&#x27;</span>] <span class="comment"># 合并成新列</span></span><br><span class="line">df[<span class="string">&quot;D&quot;</span>] = df[<span class="string">&quot;C&quot;</span>].<span class="built_in">map</span>(<span class="built_in">str</span>) + df[<span class="string">&#x27;B&#x27;</span>] <span class="comment"># 此时C列是数字</span></span><br><span class="line"></span><br><span class="line">df1.sex.value_counts() <span class="comment"># sex列分值计数</span></span><br><span class="line">df1.age.replace(<span class="string">&#x27;不详&#x27;</span>,<span class="number">0</span>,inplace=<span class="literal">True</span>) <span class="comment"># 值替代</span></span><br><span class="line">df1.age.astype(<span class="built_in">int</span>) <span class="comment"># 类型强制转换</span></span><br><span class="line"></span><br><span class="line">df.people.diff() <span class="comment"># 求前后的差值，默认为1(此时第一行会是NaN)</span></span><br><span class="line">data[<span class="string">&#x27;收盘价(元)&#x27;</span>].pct_change() <span class="comment"># 当前元素和之前元素相差的百分比，默认为1</span></span><br><span class="line">df[<span class="string">&#x27;people&#x27;</span>].rolling(<span class="number">2</span>).mean() <span class="comment"># 2个为一组向下求平均值，有交错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># map处理某一列Series，apply处理一个DateFrame</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">df</span>):</span></span><br><span class="line">    lst = df[<span class="string">&#x27;salary&#x27;</span>].split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    smin = <span class="built_in">int</span>(lst[<span class="number">0</span>].strip(<span class="string">&#x27;k&#x27;</span>))</span><br><span class="line">    smax = <span class="built_in">int</span>(lst[<span class="number">1</span>].strip(<span class="string">&#x27;k&#x27;</span>))</span><br><span class="line">    df[<span class="string">&#x27;salary&#x27;</span>] = <span class="built_in">int</span>((smin + smax) / <span class="number">2</span> * <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line">df = df.apply(func,axis=<span class="number">1</span>) <span class="comment"># 求平均工资的具体数值</span></span><br><span class="line">df[<span class="string">&#x27;sex&#x27;</span>]=df[<span class="string">&#x27;sex&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;男&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;女&#x27;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># map的函数只能接收一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_age</span>(<span class="params">x,bias</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+bias</span><br><span class="line"><span class="comment">#以元组的方式传入额外的参数</span></span><br><span class="line">data[<span class="string">&quot;age&quot;</span>] = data[<span class="string">&quot;age&quot;</span>].apply(apply_age,args=(-<span class="number">3</span>,))</span><br><span class="line">df[<span class="string">&#x27;工时&#x27;</span>]=df[<span class="string">&#x27;工时&#x27;</span>]*df[<span class="string">&#x27;工时&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;工时&#x27;</span>]=df[<span class="string">&#x27;工时&#x27;</span>]-<span class="number">3</span></span><br><span class="line">df[[<span class="string">&#x27;付费额度&#x27;</span>,<span class="string">&#x27;计费点id&#x27;</span>,<span class="string">&#x27;工时&#x27;</span>]].apply(np.log)</span><br><span class="line">np.median(df[<span class="string">&#x27;salary&#x27;</span>]) <span class="comment"># 计算中位数</span></span><br><span class="line">df.name = df.name.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="string">&#x27;1班&#x27;</span>)  <span class="comment"># lambda 表达式映射</span></span><br><span class="line"></span><br><span class="line">df1.sort_values(by=<span class="string">&#x27;comment&#x27;</span>,ascending=<span class="literal">False</span>)[:<span class="number">10</span>] <span class="comment"># 按评论数降序排列</span></span><br><span class="line">df.sort_index(ascending = <span class="literal">True</span>) <span class="comment"># 按索引升序排序</span></span><br><span class="line">df2[<span class="string">&#x27;province&#x27;</span>]=df2[<span class="string">&#x27;home&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;·&#x27;</span>).<span class="built_in">str</span>[<span class="number">0</span>] <span class="comment"># 新建一列，只获取省份</span></span><br><span class="line"></span><br><span class="line">data.groupby(<span class="string">&#x27;sex&#x27;</span>)[<span class="string">&#x27;favour&#x27;</span>].<span class="built_in">sum</span>() <span class="comment"># 分男女查看，喜爱数的总数</span></span><br><span class="line">pd.crosstab(index=data[<span class="string">&#x27;sex&#x27;</span>],columns=data[<span class="string">&#x27;martial_status&#x27;</span>]) <span class="comment"># 分男女查看，婚姻状况的状态人数，交叉表，用于计数</span></span><br><span class="line"></span><br><span class="line">data.groupby(<span class="string">&#x27;constellation&#x27;</span>)[<span class="string">&#x27;qiushi&#x27;</span>].<span class="built_in">sum</span>() <span class="comment"># 分星座查看，qiushi的发布量，agg：聚合</span></span><br><span class="line">d1=data.groupby([<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;constellation&#x27;</span>]).agg(&#123;<span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;mean&#x27;</span>&#125;) <span class="comment"># 分男女查看不同星座下年龄的平均值</span></span><br><span class="line">heros.role_assist.unique() <span class="comment"># 去重后的数值</span></span><br><span class="line">heros.role_assist.nunique() <span class="comment"># 去重后的个数</span></span><br><span class="line"></span><br><span class="line">g1=heros.groupby([<span class="string">&#x27;attack_range&#x27;</span>,<span class="string">&#x27;role_main&#x27;</span>]).agg(&#123;<span class="string">&#x27;hp_max&#x27;</span>:<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;hp_growth&#x27;</span>:<span class="string">&#x27;max&#x27;</span>&#125;) <span class="comment"># 分组后对hp_max求平均值，对hp_growth求最大值</span></span><br><span class="line"></span><br><span class="line">pd.crosstab(index=heros[<span class="string">&#x27;role_main&#x27;</span>],columns=heros[<span class="string">&#x27;attack_range&#x27;</span>]) <span class="comment"># 交叉表，用于计数</span></span><br><span class="line"></span><br><span class="line">pd.pivot_table(data=heros,index=<span class="string">&#x27;role_main&#x27;</span>,values=<span class="string">&#x27;hp_max&#x27;</span>,columns=<span class="string">&#x27;attack_range&#x27;</span>,aggfunc=<span class="string">&#x27;count&#x27;</span>,fill_value=<span class="number">0</span>) <span class="comment"># 透视表，行筛选出&#x27;role_main&#x27;，再根据&#x27;attack_range&#x27;分组统计多少种&#x27;hp_max&#x27;</span></span><br><span class="line"></span><br><span class="line">pd.pivot_table(data=heros,index=<span class="string">&#x27;role_main&#x27;</span>,columns=<span class="string">&#x27;attack_range&#x27;</span>,values=<span class="string">&#x27;hp_max&#x27;</span>,aggfunc=<span class="string">&#x27;mean&#x27;</span>,fill_value=<span class="number">0</span>) <span class="comment"># 结果表行是&#x27;role_main&#x27;,列是&#x27;attack_range&#x27;，然后对&#x27;hp_max&#x27;求平均值</span></span><br><span class="line">heros.groupby([<span class="string">&#x27;role_main&#x27;</span>,<span class="string">&#x27;attack_range&#x27;</span>])[<span class="string">&#x27;hp_max&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;col1&#x27;</span>][~df[<span class="string">&#x27;col1&#x27;</span>].isin(df[<span class="string">&#x27;col2&#x27;</span>])] <span class="comment"># 提取第一列中不在第二列出现的数字</span></span><br><span class="line">df.style.<span class="built_in">format</span>(&#123;<span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;&#123;0:.2%&#125;&#x27;</span>.<span class="built_in">format</span>&#125;) <span class="comment"># 格式化data列，23%</span></span><br><span class="line">df[<span class="string">&#x27;split&#x27;</span>] = df[<span class="string">&#x27;linestaion&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;_&#x27;</span>) <span class="comment"># 得出的是列表</span></span><br><span class="line">df[df[<span class="string">&#x27;industryField&#x27;</span>].<span class="built_in">str</span>.startswith(<span class="string">&#x27;数据&#x27;</span>)] <span class="comment"># 提取以数据开头的行</span></span><br><span class="line">df.agg(&#123;<span class="string">&quot;salary&quot;</span>:np.<span class="built_in">sum</span>,<span class="string">&quot;score&quot;</span>:np.mean&#125;) <span class="comment"># agg是聚合函数</span></span><br></pre></td></tr></table></figure><p><strong>快速画图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.people.plot(kind=<span class="string">&#x27;pie&#x27;</span>) <span class="comment"># 饼状图</span></span><br><span class="line">df.people.plot(kind=<span class="string">&#x27;hist&#x27;</span>) <span class="comment"># 直方图</span></span><br><span class="line">df.people.plot(kind=<span class="string">&#x27;bar&#x27;</span>) <span class="comment"># 柱状图</span></span><br><span class="line">df.people.plot() <span class="comment"># 折线图</span></span><br><span class="line"></span><br><span class="line">data[[<span class="string">&#x27;收盘价(元)&#x27;</span>,<span class="string">&#x27;开盘价(元)&#x27;</span>]].plot()</span><br></pre></td></tr></table></figure><p><strong>原始数据最基本的操作一定包括如下三步</strong></p><ol><li>空值的处理</li><li>重复值的处理</li><li>异常值的处理</li></ol><h2 id="2、删除重复元素"><a href="#2、删除重复元素" class="headerlink" title="2、删除重复元素"></a>2、删除重复元素</h2><p>使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True</p><ul><li>使用drop_duplicates()函数删除重复的行</li><li>使用duplicated()函数查看重复的行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df = DataFrame(data=&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:[<span class="string">&quot;lucy&quot;</span>,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;tony&quot;</span>,<span class="string">&quot;mery&quot;</span>,<span class="string">&quot;rose&quot;</span>,<span class="string">&quot;black&quot;</span>],</span><br><span class="line">    <span class="string">&quot;python&quot;</span>:np.random.randint(<span class="number">0</span>,<span class="number">100</span>,size=(<span class="number">7</span>)),</span><br><span class="line">    <span class="string">&quot;java&quot;</span>:np.random.randint(<span class="number">0</span>,<span class="number">100</span>,size=<span class="number">7</span>),</span><br><span class="line">    <span class="string">&quot;php&quot;</span>:np.random.randint(<span class="number">0</span>,<span class="number">100</span>,size=<span class="number">7</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">df.loc[df.duplicated(keep=<span class="string">&#x27;last&#x27;</span>)] <span class="comment"># 查询重复行，重复值只在行内查找</span></span><br><span class="line">df.drop_duplicates(keep=<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">df.loc[df.duplicated(subset=[<span class="string">&quot;python&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;php&quot;</span>])] <span class="comment"># 查询python、java、php成绩相同的行</span></span><br></pre></td></tr></table></figure><h2 id="3、映射"><a href="#3、映射" class="headerlink" title="3、映射"></a>3、映射</h2><p>replace属于fillna的高级版本</p><p>映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定</p><p>包含三种操作：</p><ul><li>replace()函数：替换元素（DataFrame\Series的函数)</li><li>最重要：map()函数：新建一列(Series的函数)</li><li>rename()函数：替换索引(DataFrame的函数)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df.replace(to_replace=<span class="string">&#x27;tom&#x27;</span>, value=<span class="string">&#x27;TOM&#x27;</span>) <span class="comment"># 直接替换字符串</span></span><br><span class="line">df.replace(to_replace=<span class="number">77</span>, value=<span class="number">100</span>) <span class="comment"># 替换数字</span></span><br><span class="line">df.replace(to_replace=[<span class="string">&quot;lucy&quot;</span>,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>], value=[<span class="string">&quot;LUCY&quot;</span>,<span class="string">&quot;MERY&quot;</span>,<span class="string">&quot;JACK&quot;</span>]) <span class="comment"># 使用列表替换</span></span><br><span class="line">map_dic = &#123;</span><br><span class="line">    <span class="string">&quot;lucy&quot;</span>:<span class="string">&quot;LUCY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mery&quot;</span>:<span class="string">&quot;MERY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tom&quot;</span>:<span class="string">&quot;TOM&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">df.replace(to_replace=map_dic) <span class="comment"># 使用字典替换</span></span><br><span class="line">df[<span class="string">&quot;oldname&quot;</span>] = df.name <span class="comment"># 新建一列</span></span><br><span class="line">df.replace(to_replace=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lucy&quot;</span>&#125;, value=<span class="string">&quot;LUCY-1&quot;</span>) <span class="comment"># 使用字典处理某一列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则替换</span></span><br><span class="line"><span class="comment"># to_replace 使用正则表达式</span></span><br><span class="line"><span class="comment"># regex 必须设置为True</span></span><br><span class="line">df.replace(to_replace=<span class="string">r&#x27;t.*&#x27;</span>, regex=<span class="literal">True</span>, value=<span class="string">&quot;ContainT&quot;</span>) <span class="comment"># t开头全部替换</span></span><br></pre></td></tr></table></figure><h3 id="3-1、a-replace-函数：替换元素"><a href="#3-1、a-replace-函数：替换元素" class="headerlink" title="3-1、a.replace()函数：替换元素"></a>3-1、a.replace()函数：替换元素</h3><p>使用replace()函数，对values进行替换操作</p><h3 id="3-2、Series替换操作"><a href="#3-2、Series替换操作" class="headerlink" title="3-2、Series替换操作"></a>3-2、Series替换操作</h3><ul><li>单值替换<ul><li>普通替换</li><li>字典替换</li></ul></li><li>多值替换<ul><li>列表替换</li><li>字典替换（推荐）</li></ul></li></ul><p>Series参数说明：</p><ul><li>method：对指定的值使用相邻的值填充,method不能再DataFrame当中使用</li><li>limit：设定填充次数</li></ul><h3 id="3-3、DataFrame替换操作"><a href="#3-3、DataFrame替换操作" class="headerlink" title="3-3、DataFrame替换操作"></a>3-3、DataFrame替换操作</h3><ul><li><p>单值替换</p><ul><li>普通替换</li><li>按列指定单值替换{列标签：替换值}</li></ul></li><li><p>多值替换</p><ul><li>列表替换</li><li>单字典替换（推荐）</li></ul></li></ul><p><strong>注意</strong>：DataFrame中，无法使用method和limit参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop(<span class="string">&quot;oldname&quot;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df.replace(to_replace=[<span class="number">22</span>,<span class="number">77</span>], value=[<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">df.replace(to_replace=&#123;<span class="number">22</span>:<span class="number">110</span>,<span class="number">77</span>:<span class="number">110</span>&#125;) <span class="comment"># 22换成77,77换成110</span></span><br></pre></td></tr></table></figure><h3 id="3-4、b-map-函数：新建一列"><a href="#3-4、b-map-函数：新建一列" class="headerlink" title="3-4、b.map()函数：新建一列"></a>3-4、b.map()函数：新建一列</h3><p>map 是Series的函数，所以通常被用来对某一列进行整体的映射处理</p><ul><li>map()可以使用字典映射新一列数据</li><li>map()中可以使用lambda表达式</li><li>map()中可以使用方法，可以是自定义的方法</li></ul><p><strong>注意</strong></p><ul><li>map()中不能使用sum之类的函数，for循环</li><li>map(字典) 字典的键要足以匹配所有的数据，否则出现NaN</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">map_dic = &#123;<span class="string">&#x27;lucy&#x27;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&#x27;tom&#x27;</span>:<span class="string">&quot;上海&quot;</span>,<span class="string">&#x27;jack&#x27;</span>:<span class="string">&quot;北京&quot;</span>, <span class="string">&#x27;tony&#x27;</span>:<span class="string">&quot;上海&quot;</span>, <span class="string">&#x27;mery&#x27;</span>:<span class="string">&quot;上海&quot;</span>, <span class="string">&#x27;rose&#x27;</span>:<span class="string">&quot;北京&quot;</span></span><br><span class="line">&#125; <span class="comment"># 使用字典map</span></span><br><span class="line">df[<span class="string">&quot;address&quot;</span>] = df.name.<span class="built_in">map</span>(map_dic)</span><br><span class="line">df[<span class="string">&#x27;len_str&#x27;</span>] = df[<span class="string">&#x27;grammer&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> map_dic.get(name,name)</span><br><span class="line">df[<span class="string">&quot;address&quot;</span>] = df[<span class="string">&quot;name&quot;</span>].<span class="built_in">map</span>(map_name) <span class="comment"># 使用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># map的函数只能接收一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_age</span>(<span class="params">x,bias</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+bias</span><br><span class="line"><span class="comment">#以元组的方式传入额外的参数</span></span><br><span class="line">data[<span class="string">&quot;age&quot;</span>] = data[<span class="string">&quot;age&quot;</span>].apply(apply_age,args=(-<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用函数map</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score_5</span>(<span class="params">score</span>):</span></span><br><span class="line">    <span class="keyword">if</span> score &gt; <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> score &gt; <span class="number">80</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> score &gt; <span class="number">70</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;D&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;E&quot;</span></span><br><span class="line">df.java = df.java.<span class="built_in">map</span>(score_5)</span><br><span class="line">df[<span class="string">&quot;php_5&quot;</span>] = df.php.<span class="built_in">map</span>(score_5) <span class="comment"># 函数映射</span></span><br><span class="line">df.name = df.name.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="string">&#x27;1班&#x27;</span>)  <span class="keyword">lambda</span> 表达式映射</span><br><span class="line">df.name.transform(<span class="keyword">lambda</span> x: x + <span class="string">&#x27;学员&#x27;</span>) <span class="comment"># transform()和map()类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个DataFrame做遍历的时候，默认就是遍历它的列标签</span></span><br><span class="line"><span class="comment"># 完全可以把一个DataFrame当成字典来遍历</span></span><br><span class="line"><span class="keyword">for</span> column, v <span class="keyword">in</span> score.items():</span><br><span class="line">    print(column, v)</span><br><span class="line">    print(<span class="string">&#x27;---&#x27;</span>) <span class="comment"># 结果是每次打印每列的值</span></span><br></pre></td></tr></table></figure><h3 id="3-5、c-rename-函数：替换索引，更改列名"><a href="#3-5、c-rename-函数：替换索引，更改列名" class="headerlink" title="3-5、c.rename()函数：替换索引，更改列名"></a>3-5、c.rename()函数：替换索引，更改列名</h3><p>仍然是新建一个字典</p><p>使用rename()函数替换行索引</p><ul><li>mapper 替换所有索引</li><li>index 替换行索引</li><li>columns 替换列索引</li><li>level 指定多维索引的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">score.rename(columns=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;姓名&quot;</span>&#125;,inplace=<span class="literal">True</span>) <span class="comment"># 改列名</span></span><br><span class="line">score.rename(index=&#123;<span class="string">&quot;张三&quot;</span>:<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;李四&quot;</span>:<span class="string">&quot;jack&quot;</span>&#125;,inplace=<span class="literal">True</span>) <span class="comment"># 改索引名</span></span><br><span class="line">score.set_index(<span class="string">&quot;name&quot;</span>, inplace=<span class="literal">True</span>) <span class="comment"># 重新设置name为索引</span></span><br><span class="line"></span><br><span class="line">mapper = &#123;</span><br><span class="line">    <span class="string">&quot;张三&quot;</span>:<span class="string">&quot;tom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;李四&quot;</span>:<span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;语文&quot;</span>:<span class="string">&quot;文学&quot;</span>,</span><br><span class="line">    <span class="string">&quot;英语&quot;</span>:<span class="string">&quot;外语&quot;</span>,</span><br><span class="line">    <span class="string">&quot;上学期&quot;</span>:<span class="string">&quot;FIRSTCLASS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;下学期&quot;</span>:<span class="string">&quot;SECONDCLASS&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">score.rename(mapper=mapper, axis=<span class="number">1</span>) <span class="comment"># 用字典替换，axis=1-&gt;改列名</span></span><br><span class="line"></span><br><span class="line">total = pd.concat((score1, score2), axis=<span class="number">1</span>, keys=[<span class="string">&quot;上学期&quot;</span>,<span class="string">&quot;下学期&quot;</span>])</span><br><span class="line">pd.concat([score1, score2，score3], axis=<span class="number">0</span>,ignore_index=<span class="literal">True</span>) <span class="comment"># 可以同时合并多个</span></span><br><span class="line">total.rename(mapper=mapper, axis=<span class="number">1</span>, level=-<span class="number">2</span>)</span><br><span class="line">score.columns = [<span class="string">&quot;math&quot;</span>,<span class="string">&quot;chinese&quot;</span>,<span class="string">&quot;english&quot;</span>] <span class="comment"># 也可以这样重命名列名</span></span><br></pre></td></tr></table></figure><p>使用df.std()函数可以求得DataFrame对象每一列的标准差.</p><p>尊重业务的需求  5000  10000<br>异常值通用的界定办法：如果数据是呈标准正态分布的， |data| &gt; 3*|data.std()|<br>离群点的检测： 数值型的数据都可以使用离群点的方式来检测异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = DataFrame(data=np.random.randn(<span class="number">1000</span>,<span class="number">3</span>), columns=<span class="built_in">list</span>(<span class="string">&quot;ABC&quot;</span>))</span><br><span class="line"><span class="comment"># 任意一行至少存在一个数的绝对值大于该数所处列的3倍标准差，即认定为满足异常值条件</span></span><br><span class="line">condition = (np.<span class="built_in">abs</span>(df) &gt; <span class="number">3</span>*df.std()).<span class="built_in">any</span>(axis=<span class="number">1</span>)</span><br><span class="line">df.drop(df.loc[condition].index) <span class="comment"># 删除异常列</span></span><br></pre></td></tr></table></figure><p>根据每一列或行的标准差，对DataFrame元素进行过滤。</p><p>借助any()或all()函数, 测试是否有True，有一个或以上返回True，反之返回False</p><p>对每一列应用筛选条件,去除标准差太大的数据</p><p>删除特定索引df.drop(labels,inplace = True)</p><h2 id="4、数据分类-组处理"><a href="#4、数据分类-组处理" class="headerlink" title="4、数据分类/组处理"></a>4、数据分类/组处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grouped_obj = heros.groupby(<span class="string">&quot;attack_range&quot;</span>) <span class="comment"># 根据attack_range分组，产生一个分组对象,这是对象</span></span><br><span class="line">grouped_obj.groups <span class="comment"># 查看分组对象的信息</span></span><br><span class="line">grouped_obj.mean()[[<span class="string">&quot;hp_growth&quot;</span>,<span class="string">&quot;hp_max&quot;</span>]] <span class="comment"># 分组之后一定是聚合, 聚合运算只保留可运算的列</span></span><br><span class="line"></span><br><span class="line">grouped_obj[<span class="string">&quot;hp_growth&quot;</span>].mean()</span><br><span class="line">df.groupby(<span class="string">&#x27;name&#x27;</span>).agg(&#123;<span class="string">&#x27;java&#x27;</span>:<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;python&#x27;</span>:<span class="string">&#x27;max&#x27;</span>&#125;) <span class="comment"># 分别对不同的列进行不同的聚合运算</span></span><br><span class="line"></span><br><span class="line">df.groupby(<span class="string">&#x27;name&#x27;</span>).mean()[<span class="string">&#x27;java&#x27;</span>]</span><br><span class="line">df.groupby(<span class="string">&#x27;name&#x27;</span>)[<span class="string">&#x27;java&#x27;</span>].mean() <span class="comment"># 效果同上</span></span><br><span class="line"></span><br><span class="line">h1=heros[[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hp_max&quot;</span>,<span class="string">&quot;mp_max&quot;</span>,<span class="string">&quot;attack_range&quot;</span>,<span class="string">&quot;role_main&quot;</span>]].copy()</span><br><span class="line">avg = DataFrame(h1.groupby(<span class="string">&quot;attack_range&quot;</span>)[<span class="string">&quot;hp_max&quot;</span>].mean())</span><br><span class="line"></span><br><span class="line">pd.merge(h1, avg, left_on=<span class="string">&quot;attack_range&quot;</span>, right_index=<span class="literal">True</span>, suffixes=[<span class="string">&quot;&quot;</span>, <span class="string">&quot;_avg&quot;</span>])</span><br><span class="line"></span><br><span class="line">grouped_obj1 = h1.groupby([<span class="string">&quot;attack_range&quot;</span>,<span class="string">&quot;role_main&quot;</span>])  <span class="comment"># 多字段分组</span></span><br><span class="line">grouped_obj1.groups</span><br><span class="line"></span><br><span class="line">grouped_obj1.agg(&#123;<span class="string">&quot;hp_max&quot;</span>:<span class="string">&quot;mean&quot;</span>,<span class="string">&quot;mp_max&quot;</span>:<span class="string">&quot;mean&quot;</span>&#125;).unstack(level=-<span class="number">2</span>, fill_value=<span class="number">0</span>) <span class="comment"># 这其实是一个透视表</span></span><br></pre></td></tr></table></figure><p>数据聚合是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。</p><p>数据分类处理：</p><ul><li>分组：先把数据分为几组</li><li>用函数处理：为不同组的数据应用不同的函数以转换数据</li><li>合并：把不同组得到的结果合并起来</li></ul><p>数据分类处理的核心：</p><ul><li><p>groupby()函数</p></li><li><p>groups属性查看分组情况</p></li><li><p>根据item分组,查看结果</p></li></ul><p>总结：数据类型是离散的可以分组，连续的没有意义</p><ul><li><p>获取weight的总和</p></li><li><p>把总和跟df进行merge合并</p></li><li><p>使用列表进行多列分组，得到的结果是多层级索引</p></li></ul><h2 id="5、高级数据聚合apply"><a href="#5、高级数据聚合apply" class="headerlink" title="5、高级数据聚合apply()"></a>5、高级数据聚合apply()</h2><h3 id="5-1、apply直接在groupby后面，传入的是整个df，直接在df后传入的是一列或者一行"><a href="#5-1、apply直接在groupby后面，传入的是整个df，直接在df后传入的是一列或者一行" class="headerlink" title="5-1、apply直接在groupby后面，传入的是整个df，直接在df后传入的是一列或者一行"></a>5-1、apply直接在groupby后面，传入的是整个df，直接在df后传入的是一列或者一行</h3><p> 使用groupby分组后，也可以使用transform和apply提供自定义函数实现更多的运算</p><ul><li>df.groupby(‘item’)[‘price’].sum() &lt;==&gt; df.groupby(‘item’)[‘price’].apply(sum)</li><li>transform和apply都会进行运算，在transform或者apply中传入函数即可</li><li>transform和apply也可以传入一个lambda表达式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;new&#x27;</span>]=df.apply(<span class="keyword">lambda</span> x:x.php-x.java,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">h1.groupby(<span class="string">&quot;role_main&quot;</span>)[<span class="string">&quot;mp_max&quot;</span>].mean()</span><br><span class="line">h1.groupby(<span class="string">&quot;role_main&quot;</span>)[<span class="string">&quot;mp_max&quot;</span>,<span class="string">&quot;mp,min&quot;</span>].apply(np.mean) </span><br><span class="line"><span class="comment"># 如果不是官方聚合函数，可以使用apply传递,按列计算时是每一列当成一个Series传入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组对象的聚合函数，接受的是每一个分组,定制一个最大值和平均值的差的聚合函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">group_function</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">max</span>() - x.mean()</span><br><span class="line">df = DataFrame(h1.groupby(<span class="string">&quot;role_main&quot;</span>)[<span class="string">&quot;mp_max&quot;</span>].apply(group_function))</span><br><span class="line">df.columns = [<span class="string">&quot;max-mean&quot;</span>]</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;yu_shu&#x27;</span>]=df.apply(<span class="keyword">lambda</span> x:x[<span class="string">&#x27;yu&#x27;</span>]-x[<span class="string">&#x27;shu&#x27;</span>])</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>transform 会自动匹配列索引返回值，不去重</li><li>apply 会根据分组情况返回值，去重</li></ul><h3 id="5-2、交叉表"><a href="#5-2、交叉表" class="headerlink" title="5-2、交叉表"></a>5-2、交叉表</h3><p>交叉表(cross-tabulation, 简称crosstab)是一种用于计算分组频率的特殊透视表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.crosstab(index=h1[<span class="string">&quot;role_main&quot;</span>], columns=h1[<span class="string">&quot;attack_range&quot;</span>])</span><br></pre></td></tr></table></figure><h3 id="5-3、透视表"><a href="#5-3、透视表" class="headerlink" title="5-3、透视表"></a>5-3、透视表</h3><p>透视表(pivot table)是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上得分组建将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除了能为groupby提供便利之外，pivot_table还可以添加分项小计（也叫margins）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透视表</span></span><br><span class="line">pd.pivot_table(data=h1, values=<span class="string">&quot;hp_max&quot;</span>, index=<span class="string">&quot;role_main&quot;</span>, columns=<span class="string">&quot;attack_range&quot;</span>,aggfunc=<span class="string">&quot;mean&quot;</span>, fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pd.pivot_table(columns=<span class="string">&#x27;behavior_type&#x27;</span>,index=<span class="string">&#x27;hour&#x27;</span>,data=df,values=<span class="string">&#x27;user_id&#x27;</span>,aggfunc=np.size) <span class="comment">#透视图</span></span><br><span class="line">df.groupby([<span class="string">&#x27;hour&#x27;</span>,<span class="string">&#x27;behavior_type&#x27;</span>])[<span class="string">&#x27;user_id&#x27;</span>].count().unstack(<span class="number">1</span>).head() <span class="comment"># 效果同上</span></span><br></pre></td></tr></table></figure><h2 id="6、分箱操作：cut和qcut函数"><a href="#6、分箱操作：cut和qcut函数" class="headerlink" title="6、分箱操作：cut和qcut函数"></a>6、分箱操作：cut和qcut函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rfm[<span class="string">&#x27;M-SCORE&#x27;</span>]=pd.cut(rfm[<span class="string">&#x27;M&#x27;</span>],bins=[<span class="number">0</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">250</span>,<span class="number">10000</span>],labels=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],right=<span class="literal">False</span>).astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;categories&#x27;</span>] = pd.cut(df[<span class="string">&#x27;salary&#x27;</span>],bins = [<span class="number">0</span>,<span class="number">5000</span>,<span class="number">20000</span>,<span class="number">50000</span>],labels=[<span class="string">&#x27;低&#x27;</span>,<span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;高&#x27;</span>])</span><br></pre></td></tr></table></figure><p><code>x</code>：被切分的类数组（array-like）数据，必须是1维的（不能用DataFrame）；</p><p><code>bins</code>：bins是被切割后的区间（或者叫“桶”、“箱”、“面元”），有3中形式：一个int型的标量、标量序列（数组）或者pandas.IntervalIndex 。一个int型的标量. 当bins为一个int型的标量时，代表将x平分成bins份。x的范围在每侧扩展0.1%，以包括x的最大值和最小值。标量序列. 标量序列定义了被分割后每一个bin的区间边缘，此时x没有扩 .pandas.IntervalIndex<br>定义要使用的精确区间。</p><p><code>right</code>：bool型参数，默认为True，表示是否包含区间右部。比如如果bins=[1,2,3]，right=True，则区间为(1,2]，(2,3]；right=False，则区间为(1,2),(2,3)。</p><p><code>labels</code>：给分割后的bins打标签，比如把年龄x分割成年龄段bins后，可以给年龄段打上诸如青年、中年的标签。labels的长度必须和划分后的区间长度相等，比如bins=[1,2,3]，划分后有2个区间(1,2]，(2,3]，则labels的长度必须为2。如果指定labels=False，则返回x中的数据在第几个bin中（从0开始）。</p><p><code>retbins</code>：bool型的参数，表示是否将分割后的bins返回，当bins为一个int型的标量时比较有用，这样可以得到划分后的区间，默认为False。</p><p><code>precision</code>：保留区间小数点的位数，默认为3.</p><p><code>include_lowest</code>：bool型的参数，表示区间的左边是开还是闭的，默认为false，也就是不包含区间左部（闭）<code>duplicates</code>：是否允许重复区间。有两种选择：<code>raise</code>：不允许，<code>drop</code>：允许。</p><h3 id="6-1、pd-qcut-参数介绍"><a href="#6-1、pd-qcut-参数介绍" class="headerlink" title="6-1、pd.qcut()参数介绍"></a>6-1、pd.qcut()参数介绍</h3><p>基于分位数的离散化功能。 将变量离散化为基于等级或样本分位数的相等大小的存储桶。</p><p>和pd.cut()相比，pd.qcut()的参数少了两个，少了right和include_lowest两个参数，剩下的参数几乎和pd.cut()一模一样了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.qcut(x, q, labels=<span class="literal">None</span>, retbins=<span class="literal">False</span>, precision=<span class="number">3</span>, duplicates=<span class="string">&#x27;raise&#x27;</span>)</span><br></pre></td></tr></table></figure><p>x ：一维数组或者Serise</p><p>q ： 表示分位数的整数或者数组，</p><ul><li>如果是分位数的整数，例如10用于十分位，4用于四分位</li><li>如果是分位数数组，例如[0,0.25,0.5,0.75,1]用于四分位数</li></ul><p>labels ： 数组或者布尔值，默认为none，用于指定每个箱体的标签</p><ul><li>如果是数组，长度要与分箱个数一致，比如用四分位数分箱，需要指定四个标签</li><li>如果为False，则仅返回分箱的整数指示符，即当前数据位于哪个箱子中</li></ul><p>rebines ：布尔值，可选。 是否显示分箱的分界值。（由于是按照分位数进行分箱，在不知道分位数具体数值的情况下，可以通过这个参数设置显示分界值即分位数的具体数值）</p><p>precision：整数，默认3，存储和显示分箱标签的精度。</p><p>duplicates：如果分箱临界值不唯一，则引发ValueError或丢弃非唯一</p><h2 id="7、哑变量-独热编码-处理"><a href="#7、哑变量-独热编码-处理" class="headerlink" title="7、哑变量(独热编码)处理"></a>7、哑变量(独热编码)处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">&quot;x&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="string">&quot;季节&quot;</span>:[<span class="string">&quot;春&quot;</span>,<span class="string">&quot;夏&quot;</span>,<span class="string">&quot;秋&quot;</span>,<span class="string">&quot;冬&quot;</span>,<span class="string">&quot;秋&quot;</span>]&#125;)</span><br><span class="line">data =pd.get_dummies(data,columns=[<span class="string">&quot;季节&quot;</span>],prefix_sep=<span class="string">&#x27;_&#x27;</span>,dummy_na=<span class="literal">False</span>,drop_first=<span class="literal">False</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure><ul><li><strong>data</strong> : array-like, Series, or DataFrame 输入的数据</li><li><strong>prefix</strong> : string, get_dummies转换后，列名的前缀，默认为None</li><li><strong>columns</strong> : 指定需要实现类别转换的列名，否则转换所有<strong>类别</strong>性的列(数字列不会转换)</li><li><strong>dummy_na</strong> : bool, default False 增加一列表示空缺值，如果False就忽略空缺值</li><li><strong>drop_first</strong> : bool, default False 获得k中的k-1个类别值，去除第一个,防止出现多重共线性</li></ul><p><strong>注意：</strong></p><p>若针对训练数据已经做好了独热编码并建立了模型，而<strong>新增的预测数据或分类数据的类别变量未包含完整的类别</strong>。此时直接使用pd.get_dummies，会发现与训练集得到的结果不一样。例如：训练数据中季节列中春、夏、秋、冬都出现过，而在新的测试数据中只出现了春与夏，两者的结果会不一样。</p><p>为了避免出现这个情况，需要新增以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&#x27;季节&#x27;</span>] = data[<span class="string">&#x27;季节&#x27;</span>].astype(</span><br><span class="line">    <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">    categories=[<span class="string">&quot;春&quot;</span>, <span class="string">&quot;夏&quot;</span>, <span class="string">&quot;秋&quot;</span>, <span class="string">&quot;冬&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="8-时间序列"><a href="#8-时间序列" class="headerlink" title="8-时间序列"></a>8-时间序列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time ,timedelta <span class="comment"># datetime模块里的datetime类,date类，time类</span></span><br><span class="line">x=datetime(<span class="number">2020</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">45</span>)  <span class="comment"># datetime.datetime(2020, 7, 3, 17, 6, 45)，生成一个日期时间对象，也可以只传入日期，时间默认为00:00:00</span></span><br><span class="line">date(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">15</span>)  <span class="comment"># datetime.date(2020, 11, 15)，创建一个日期</span></span><br><span class="line">time(<span class="number">18</span>, <span class="number">23</span>, <span class="number">45</span>) <span class="comment"># datetime.time(10, 53, 21)，创建一个时间</span></span><br><span class="line"></span><br><span class="line">x.date()  <span class="comment"># 2020-07-03 # 提取日期对象</span></span><br><span class="line">x.time()  <span class="comment"># 17:06:45 # 提取时间对象</span></span><br><span class="line">x.year  <span class="comment"># 2020 # 整数int</span></span><br><span class="line">x.month  <span class="comment"># 7</span></span><br><span class="line">x.day  <span class="comment"># 3</span></span><br><span class="line">x.hour  <span class="comment"># 17</span></span><br><span class="line">x.minute <span class="comment"># 6</span></span><br><span class="line">x.second <span class="comment"># 45</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime转字符串，</span></span><br><span class="line">x.strftime(<span class="string">&#x27;%m/%d/%Y %H:%M:%S&#x27;</span>) <span class="comment"># &#x27;07/03/2020 17:06:45&#x27;，指定格式</span></span><br><span class="line"><span class="built_in">str</span>(x) <span class="comment"># &#x27;2020-07-03 17:06:45&#x27;，默认格式</span></span><br><span class="line"><span class="comment"># 字符串转datetime</span></span><br><span class="line">datetime.strptime(<span class="string">&#x27;7/6/2011 18:00:00&#x27;</span>, <span class="string">&#x27;%m/%d/%Y %H:%M:%S&#x27;</span>) <span class="comment">#datetime.datetime(2011, 7, 6, 18, 0)</span></span><br><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse <span class="comment"># dateutil几乎可以解析所有日期表示形式</span></span><br><span class="line">parse(<span class="string">&quot;Jan 31, 2020 10:45:02 PM&quot;</span>) <span class="comment"># datetime.datetime(2020, 1, 31, 22, 45, 2)</span></span><br><span class="line"></span><br><span class="line">x.replace(minute=<span class="number">0</span>,second=<span class="number">0</span>) <span class="comment"># datetime.datetime(2020, 7, 3, 17, 0)替换</span></span><br><span class="line">datetime.now() <span class="comment"># datetime.datetime(2020, 11, 15, 21, 31, 22, 838494) # 获取当前的日期时间</span></span><br><span class="line">datetime.now() + timedelta(<span class="number">3</span>)  <span class="comment"># 计算三天以后的日期时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间差可以通过两个datetime对象相减得到，可以创建得到</span></span><br><span class="line">dt=datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">15</span>) <span class="comment"># datetime.timedelta(days=926, seconds=56700),dt是timedelta对象</span></span><br><span class="line">c = timedelta(days=<span class="number">9</span>,weeks=<span class="number">2</span>,hours=<span class="number">8</span>,seconds=<span class="number">23</span>,minutes=<span class="number">12</span>) <span class="comment"># datetime.timedelta(days=23, seconds=29543)，创建一个时间差</span></span><br><span class="line">c.days <span class="comment"># 取时间差的天数,有正负</span></span><br><span class="line">c.seconds <span class="comment"># 取时间差的秒数，为正</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">x.timestamp()  <span class="comment"># 1593767205.0 # 获取对应的时间戳，可用时间戳求相隔小时</span></span><br><span class="line">datetime.fromtimestamp(t) <span class="comment"># 从时间戳获取时间</span></span><br><span class="line"></span><br><span class="line">x.weekday() <span class="comment"># 获取a所在的日期是周几，周一是0，以此类推</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.to_datetime(....)</span><br><span class="line">pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">3</span>) <span class="comment"># 生成连续的3天</span></span><br><span class="line">pd.date_range(<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>)</span><br><span class="line">dfdf[<span class="string">&#x27;付款日期&#x27;</span>].dt <span class="comment"># 转换成datetime</span></span><br><span class="line">(datetime(<span class="number">2019</span>,<span class="number">8</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">12</span>,<span class="number">45</span>)-dfdf[<span class="string">&#x27;付款日期&#x27;</span>]).dt <span class="comment"># 类似timedelta类型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、基本处理&quot;&gt;&lt;a href=&quot;#1、基本处理&quot; class=&quot;headerlink&quot; title=&quot;1、基本处理&quot;&gt;&lt;/a&gt;1、基本处理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;map仅能处理单列&lt;/li&gt;
&lt;li&gt;apply能处理单列或多列，如果直接对df.apply(f</summary>
      
    
    
    
    
    <category term="python" scheme="https://actionou.github.io/tags/python/"/>
    
    <category term="pandas" scheme="https://actionou.github.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>写出优雅的Python代码之—仓库结构（译）</title>
    <link href="https://actionou.github.io/2020/01/10/great-python-code-structure/"/>
    <id>https://actionou.github.io/2020/01/10/great-python-code-structure/</id>
    <published>2020-01-10T11:55:22.000Z</published>
    <updated>2020-12-02T15:11:35.487Z</updated>
    
    <content type="html"><![CDATA[<p>我们对于“结构化”的定义是您关注于怎样使您的项目最好地满足它的对象性，我们需要去考虑如何更好地利用Python的特性来创造简洁、高效的代码。在实践层面， “结构化”意味着通过编写简洁的代码，并且正如文件系统中文件和目录的组织一样，代码应该使逻辑和依赖清晰。</p><p>哪个函数应该深入到哪个模块？数据在项目中如何流转？什么功能和函数应该组合或独立？要解决这些问题，您可以开始做一个计划，大体来说，即是您的最终产品看起来会是怎样的。</p><p>在这一章节中，我们更深入地去观察Python的模块和导入系统，因为它们是加强您的项目结构化的关键因素，接着我们会从不同层面去讨论如何去构建可扩展且测试可靠的的代码。</p><h2 id="仓库结构很重要"><a href="#仓库结构很重要" class="headerlink" title="仓库结构很重要"></a>仓库结构很重要</h2><p>在一个健康的开发周期中，代码风格、API设计和自动化是非常关键的。同样的，对于项目架构，仓库的结构也是关键的一部分。</p><p>当一个潜在的用户和代码贡献者访问您的代码仓库时，他们会看到这些:</p><ul><li>工程的名字</li><li>工程的描述</li><li>一系列的文件</li></ul><p>只有当他们滚动到目录下方时才会看到您工程的README。</p><p>如果您的仓库的目录一团糟，没有清晰的结构，他们可能要到处寻找才能发现您写的<strong>漂亮</strong>的文档。</p><blockquote><p>为您渴望的事业而奋斗，而不仅仅只是为您现在的工作而工作。</p></blockquote><p>当然，第一印象并不决定一切。但是，您和您的同事会和这个仓库并肩战斗很长时间，会接触它的每一个角落和细节。拥有良好的布局，事半功倍。</p><h2 id="仓库样例"><a href="#仓库样例" class="headerlink" title="仓库样例"></a>仓库样例</h2><p>请看这里: 这是 <a href="http://kennethreitz.org/">Kenneth Reitz</a> 推荐的。<br>这个项目可以在GitHub上找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">LICENSE</span><br><span class="line">setup.py</span><br><span class="line">requirements.txt</span><br><span class="line">sample&#x2F;__init__.py</span><br><span class="line">sample&#x2F;core.py</span><br><span class="line">sample&#x2F;helpers.py</span><br><span class="line">docs&#x2F;conf.py</span><br><span class="line">docs&#x2F;index.rst</span><br><span class="line">tests&#x2F;test_basic.py</span><br><span class="line">tests&#x2F;test_advanced.py</span><br></pre></td></tr></table></figure><p>让我们再继续看一些细节。</p><h2 id="真正的模块"><a href="#真正的模块" class="headerlink" title="真正的模块"></a>真正的模块</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./sample/</code> or <code>./sample.py</code></td><td align="center">核心代码</td></tr></tbody></table><p>您的模块包是这个仓库的核心，它不应该隐藏起来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;sample&#x2F;</span><br></pre></td></tr></table></figure><p>如果您的模块只有一个文件，那么您可以直接将这个文件放在仓库的根目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;sample.py</span><br></pre></td></tr></table></figure><p>这个模块文件不应该属于任何一个模棱两可的src或者python子目录。</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left">./LICENSE</td><td align="center">许可证</td></tr></tbody></table><p>除了源代码本身以外，这个毫无疑问是您仓库最重要的一部分。在这个文件中要有完整的许可说明和授权。<br>如果您不太清楚您应该使用哪种许可方式，请查看 <a href="http://choosealicense.com/">choosealicense.com</a>.<br>当然，您也可以在发布您的代码时不做任何许可说明，但是这显然阻碍潜在的用户使用您的代码。</p><h2 id="Setup-py"><a href="#Setup-py" class="headerlink" title="Setup.py"></a>Setup.py</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./setup.py</code></td><td align="center">打包和发布管理</td></tr></tbody></table><p>如果您的模块包在您的根目录下，显然这个文件也应该在根目录下。</p><h2 id="Requirements-File"><a href="#Requirements-File" class="headerlink" title="Requirements File"></a>Requirements File</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./requirements.txt</code></td><td align="center">开发依赖</td></tr></tbody></table><p>一个 <a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files">pip requirements file</a> 应该放在仓库的根目录。它应该指明完整工程的所有依赖包: 测试, 编译和文档生成。</p><p>如果您的工程没有任何开发依赖，或者您喜欢通过<code>setup.py</code>来设置，那么这个文件不是必须的。</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./docs/</code></td><td align="center">包的参考文档</td></tr></tbody></table><p>没有任何理由把这个放到别的地方。</p><h2 id="Test-Suite"><a href="#Test-Suite" class="headerlink" title="Test Suite"></a>Test Suite</h2><p>想了解关于编写测试的建议，请查阅 <a href="https://docs.python-guide.org/writing/tests/">Testing Your Code</a>.</p><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./test_sample.py</code> or <code>./tests</code></td><td align="center">包的集合和单元测试</td></tr></tbody></table><p>最开始，一组测试例子只是放在一个文件当中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;test_sample.py</span><br></pre></td></tr></table></figure><p>当测试例子逐步增加时，您会把它放到一个目录里面，像下面这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tests&#x2F;test_basic.py</span><br><span class="line">tests&#x2F;test_advanced.py</span><br></pre></td></tr></table></figure><p>当然，这些测试例子需要导入您的包来进行测试，有几种方式来处理:</p><ul><li>将您的包安装到site-packages中。</li><li>通过简单直接的路径设置来解决导入的问题。</li></ul><p>我极力推荐后者。如果使用<code>setup.py develop</code>来测试一个持续更新的代码库，需要为每一个版本的代码库设置一个独立的测试环境.太麻烦了。</p><p>可以先创建一个包含上下文环境的文件<code>tests/context.py</code>。 file:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sample</span><br></pre></td></tr></table></figure><p>然后，在每一个测试文件中，导入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .context <span class="keyword">import</span> sample</span><br></pre></td></tr></table></figure><p>这样就能够像期待的那样工作，而不用采用安装的方式。</p><p>一些人会说应该把您的测试例子放到您的模块里面。我不同意。这样会增加您用户使用的复杂度；而且添加测试模块将导致需要额外的依赖和运行环境。</p><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./Makefile</code></td><td align="center">常规的管理任务</td></tr></tbody></table><p>如果您看看我的项目或者其他开源项目，您都会发现有一个Makefile。为什么？这些项目也不是用C写的啊。。。简而言之，make对于定义常规的管理任务是非常有用的工具。</p><p><strong>样例 Makefile:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init:</span><br><span class="line">    pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">    py.test tests</span><br><span class="line"></span><br><span class="line">.PHONY: init test</span><br></pre></td></tr></table></figure><p>一些其他的常规管理脚本（比如<code>manage.py</code>或者<code>fabfile.py</code>），也放在仓库的根目录下。</p><h2 id="关于-Django-Applications"><a href="#关于-Django-Applications" class="headerlink" title="关于 Django Applications"></a>关于 Django Applications</h2><p>从Django 1.4开始，有这样一个现象：很多开发者错误地使用Django自带的应用模板创建项目，导致他们的仓库结构非常糟糕。</p><p>这是怎么回事呢? 原来, 他们在创建一个新的仓库后通常都这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite</span><br></pre></td></tr></table></figure><p>这样子操作生成的仓库结构是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">samplesite&#x2F;manage.py</span><br><span class="line">samplesite&#x2F;samplesite&#x2F;settings.py</span><br><span class="line">samplesite&#x2F;samplesite&#x2F;wsgi.py</span><br><span class="line">samplesite&#x2F;samplesite&#x2F;sampleapp&#x2F;models.py</span><br></pre></td></tr></table></figure><p>亲，不要这样做。</p><p>相对路径会让您的工具和您的开发者都很疑惑。没有必要的嵌套对任何人都没有好处（除非您怀念庞大的SVN仓库）。</p><p>让我们这样来做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite .</span><br></pre></td></tr></table></figure><p>注意末尾的”<code>.</code>“。</p><p>生成的结构是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">manage.py</span><br><span class="line">samplesite&#x2F;settings.py</span><br><span class="line">samplesite&#x2F;wsgi.py</span><br><span class="line">samplesite&#x2F;sampleapp&#x2F;models.py</span><br></pre></td></tr></table></figure><blockquote><p>END</p></blockquote><hr><p>翻译自 <a href="https://docs.python-guide.org/writing/structure/">https://docs.python-guide.org/writing/structure/</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们对于“结构化”的定义是您关注于怎样使您的项目最好地满足它的对象性，我们需要去考虑如何更好地利用Python的特性来创造简洁、高效的代码。在实践层面， “结构化”意味着通过编写简洁的代码，并且正如文件系统中文件和目录的组织一样，代码应该使逻辑和依赖清晰。&lt;/p&gt;
&lt;p&gt;哪</summary>
      
    
    
    
    
    <category term="python" scheme="https://actionou.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python中的单例模式</title>
    <link href="https://actionou.github.io/2019/12/02/python-singleton/"/>
    <id>https://actionou.github.io/2019/12/02/python-singleton/</id>
    <published>2019-12-02T14:50:20.000Z</published>
    <updated>2020-12-02T15:11:47.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>​单例模式<code>Singleton Pattern</code>是一种常用的<strong>软件设计模式</strong>，该模式的主要目的是确保某一个类只有一个实例存在。</p><p><strong>拓展</strong>：软件设计模式<br>在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。<br>refer:<a href="http://c.biancheng.net/view/1320.html">http://c.biancheng.net/view/1320.html</a></p><table><thead><tr><th>范围\目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法</td><td>(类)适配器</td><td>模板方法、解释器</td></tr><tr><td>对象模式</td><td>单例<br/>原型<br/>抽象工厂<br/>建造者</td><td>代理<br/>(对象)适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/>组合</td><td>策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器<br/>访问者<br/>备忘录</td></tr></tbody></table><h2 id="Python中实现单例模式的方法"><a href="#Python中实现单例模式的方法" class="headerlink" title="Python中实现单例模式的方法"></a>Python中实现单例模式的方法</h2><h3 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1.使用模块"></a>1.使用模块</h3><p><strong>即文件导入的形式：</strong><br>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p><p><strong>pyc是什么文件?</strong><br>pyc是一种二进制文件，是由py文件经过编译后，生成的文件，是一种byte code，py文件变成pyc文件后，运行加载的速度会有所提高；另一反面，把py文件编译为pyc文件，从而可以实现部分的源码隐藏，保证了python做商业化软件时的安全性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s1.py 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># v是Foo的实例</span></span><br><span class="line">foo = Foo()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s2.py 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> s1 <span class="keyword">import</span> foo <span class="keyword">as</span> f1</span><br><span class="line">print(f1,<span class="built_in">id</span>(f1))  <span class="comment">#&lt;s1.Foo object at 0x0000000002221710&gt;  35788560</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> s1 <span class="keyword">import</span> foo <span class="keyword">as</span> f2</span><br><span class="line">print(f2,<span class="built_in">id</span>(f2))   <span class="comment">#&lt;s1.Foo object at 0x0000000002221710&gt;  35788560</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个的内存地址是一样的</span></span><br><span class="line"><span class="comment"># 第一次导入后，再次导入时不会再重新加载，而是直接加载.pyc文件</span></span><br></pre></td></tr></table></figure><h3 id="2-基于-new-方法实现的单例模式"><a href="#2-基于-new-方法实现的单例模式" class="headerlink" title="2.基于__new__方法实现的单例模式"></a>2.基于__new__方法实现的单例模式</h3><p>当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__）实例化对象；然后再执行类的__init__方法，对这个对象进行初始化等操作，<br>所以我们可以基于这个，对__new__方法做一些手脚，实现单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;基于__new__方法一&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __new__(cls):</span><br><span class="line">        # 这个函数是判断指定对象中是否有某属性，内部实现是调用了getattr()，并捕获AttributeError异常。</span><br><span class="line">        # 利用反射看看这个类有没有instance属性</span><br><span class="line">        if not hasattr(cls, &#39;instance&#39;):</span><br><span class="line">            # 调用 __new__ 方法申请内存</span><br><span class="line">            # 如果不重写 __new__ 方法，会调用 object 的 __new__方法申请内存</span><br><span class="line">            # 如果重写了 __new__ 方法，需要自己手动的申请内存</span><br><span class="line">            cls.instance &#x3D; super(Foo, cls).__new__(cls)</span><br><span class="line">        return cls.instance</span><br></pre></td></tr></table></figure><p><strong>什么是反射？</strong><br>在面向对象的思想中，把对象能够访问、查询、修改自身的状态或行为称为“反射”。</p><p><strong>python中的反射</strong><br>在python中，可以通过字符串的的形式来操作对象的属性。这种行为称之为python中的反射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============基于__new__方法二=============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 定义一个类属性，用来保存实例化的对象</span></span><br><span class="line">    <span class="comment"># 私有类属性</span></span><br><span class="line">    __instance = <span class="literal">None</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 1.判断类属性是否为空</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 2.调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.__instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">            print(cls.__instance)</span><br><span class="line">        <span class="comment"># 3.返回类属性保存的对象的应用</span></span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br></pre></td></tr></table></figure><h3 id="3-使用类方法"><a href="#3-使用类方法" class="headerlink" title="3.使用类方法"></a>3.使用类方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路就是,调用类的instance方法,这样有一个弊端就是在使用类创建的时候,并不是单例了.也就是说在创建类的时候一定要用类里面规定的方法创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 利用反射 看看这个类有没有_instance属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">s1 = Singleton()  <span class="comment"># 这样创建的对象并不是单例</span></span><br><span class="line">s2 = Singleton.get_instance() <span class="comment"># 要调用特定的方法创建单例对象</span></span><br></pre></td></tr></table></figure><h3 id="4-使用装饰器-推荐使用"><a href="#4-使用装饰器-推荐使用" class="headerlink" title="4.使用装饰器(推荐使用)"></a>4.使用装饰器(推荐使用)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============函数装饰器=============</span></span><br><span class="line"><span class="comment"># 1.把类当成函数传递给装饰器</span></span><br><span class="line"><span class="comment"># 2.创建类的实例的时候调用Foo已经变成了调用inner。</span></span><br><span class="line"><span class="comment"># 3.在inner内部实现单例类的创建</span></span><br><span class="line"><span class="comment"># 4.因此foo1、foo2的值都等于inner返回值。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">fun</span>):</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">if</span> fun <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            <span class="comment"># 使用不可变的类地址作为键，其实例作为值，</span></span><br><span class="line">            <span class="comment"># 每次创造实例时，首先查看该类是否存在实例，</span></span><br><span class="line">            <span class="comment"># 存在的话直接返回该实例即可，</span></span><br><span class="line">            <span class="comment"># 否则新建一个实例并存放在字典中。</span></span><br><span class="line">            _instance[fun] = fun()</span><br><span class="line">        <span class="keyword">return</span> _instance[fun]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(foo1 <span class="keyword">is</span> foo2)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===========类装饰器============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        self.cls = cls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            Singleton._instance = self.cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="comment"># Demo已经变了，Demo已经是Singleton的实例了，在Singleton里面加入了__call__方法，让实例可以被调用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">do1 = Demo()</span><br><span class="line">do2 = Demo()</span><br><span class="line">print(<span class="built_in">id</span>(do1), <span class="built_in">id</span>(do2))</span><br></pre></td></tr></table></figure><h3 id="5-共享属性（不推荐使用）"><a href="#5-共享属性（不推荐使用）" class="headerlink" title="5.共享属性（不推荐使用）"></a>5.共享属性（不推荐使用）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)  </span></span><br><span class="line"><span class="comment">#同一个类的所有实例天然拥有相同的行为(方法),  </span></span><br><span class="line"><span class="comment">#只需要保证同一个类的所有实例具有相同的状态(属性)即可  </span></span><br><span class="line"><span class="comment">#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        ob = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span>(<span class="params">Singleton</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;最后的结果是<span class="subst">&#123;self.name&#125;</span>&#x27;</span>) <span class="comment"># 实例化N个对象打印的都是最后创建的对象的name属性</span></span><br></pre></td></tr></table></figure><h3 id="6-基于metaclass-元类-实现的单例模式"><a href="#6-基于metaclass-元类-实现的单例模式" class="headerlink" title="6.基于metaclass(元类)实现的单例模式"></a>6.基于metaclass(元类)实现的单例模式</h3><p><strong>什么是元类？</strong><br>实例对象是由类来创建，那么类又是由什么来创建的呢？ 答案就是元类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            cls._instance = <span class="built_in">super</span>(SingletonType, cls).__call__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)</span></span><br><span class="line"><span class="comment"># metaclass=SingletonType 这样就表示调用SingletonType的__call__方法来创建Foo类</span></span><br><span class="line"><span class="comment"># 判断实例化的对象是否有_instance这个属性</span></span><br><span class="line"><span class="comment"># 然后调用父类type的__call__方法创建Foo对象(类)</span></span><br><span class="line"><span class="comment"># 同时Foo创建了就会调用Foo类的__new__方法和__init__方法实例化对象</span></span><br><span class="line"><span class="comment"># 返回这个实例化对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonType</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Foo(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">obj2 = Foo(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line">print(obj1, obj2)</span><br><span class="line">print(<span class="built_in">id</span>(obj1), <span class="built_in">id</span>(obj2))</span><br></pre></td></tr></table></figure><p>元类实现单例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonMeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">cls,*args, **kwargs</span>):</span></span><br><span class="line">    <span class="comment"># 这个self是指定了使用SingletonMeta作为元类的类对应的对象</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        cls.__instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了metaclass=type的话，就会实现单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">President</span>(<span class="params"><span class="built_in">object</span>, metaclass=<span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">President() <span class="comment"># 这个类是SingletonMeta创建出的对象，那么在类后面加()，相当于调用了元类(type)的__call__魔术方法。所以可以在__call__里面做文章，来实现单例。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了metaclass=type的话，就会实现单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonMeta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h2&gt;&lt;p&gt;​单例模式&lt;code&gt;Singleton Pattern&lt;/code&gt;是一种常用的&lt;strong&gt;软</summary>
      
    
    
    
    
    <category term="python" scheme="https://actionou.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>vimrc</title>
    <link href="https://actionou.github.io/2019/07/01/vimrc/"/>
    <id>https://actionou.github.io/2019/07/01/vimrc/</id>
    <published>2019-07-01T15:26:01.000Z</published>
    <updated>2020-12-02T14:54:03.307Z</updated>
    
    <content type="html"><![CDATA[<p><code>pycharm</code>和<code>jupyter notebook</code>是我的主要coding工具，但偶尔也免不了直接在终端进行编辑，所以根据自己的需求和使用习惯对vim配置做了如下简单的调整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">&quot; 使用 utf-8 编码</span><br><span class="line">set encoding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">&quot; 去掉有关vi一致性模式,避免操作习惯上的局限.</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; 让Backspace键可以往前删除字符.</span><br><span class="line">set backspace&#x3D;indent,eol,start</span><br><span class="line"></span><br><span class="line">&quot; 总是显示状态行</span><br><span class="line">set laststatus&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; 在状态栏显示光标的当前位置（位于哪一行哪一列）</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">&quot; 显示还没有输入完整的命令.例如yy命令,输入第一个y会在右下角显示y.</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 关闭自动折行</span><br><span class="line">set nowrap</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示所有搜索到的内容</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 光标立刻跳转到搜索到内容</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot; 搜索时忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 搜索到最后匹配的位置后,再次搜索不回到第一个匹配处</span><br><span class="line">set nowrapscan</span><br><span class="line"></span><br><span class="line">&quot; 设置Esc超时时间为100ms,尽快生效</span><br><span class="line">set ttimeout</span><br><span class="line">set ttimeoutlen&#x3D;100</span><br><span class="line"></span><br><span class="line">&quot; 高亮光标所在的行</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">&quot; 开启语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 在底部显示，当前处于命令模式还是插入模式</span><br><span class="line">set showmode</span><br><span class="line"></span><br><span class="line">&quot; 命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">&quot; 检测文件类型,并载入文件类型插件,为特定文件类型载入相关缩进文件</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 按下 Tab 键时，Vim 显示的空格数</span><br><span class="line">set tabstop&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; 在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者&#x3D;&#x3D;（取消全部缩进）时，每一级的字符数</span><br><span class="line">set shiftwidth&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; 输入Tab字符时,自动替换成空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot; 设置softtabstop有一个好处是可以用Backspace键来一次删除4个空格.</span><br><span class="line">&quot; softtabstop的值为负数,会使用shiftwidth的值,两者保持一致,方便统一缩进.</span><br><span class="line">set softtabstop&#x3D;-1</span><br><span class="line"></span><br><span class="line">&quot; 使用 utf-8 编码</span><br><span class="line">set encoding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">&quot; 垂直滚动时，光标距离顶部&#x2F;底部的位置（单位：行）</span><br><span class="line">set scrolloff&#x3D;5</span><br><span class="line"></span><br><span class="line">&quot; 水平滚动时，光标距离行首或行尾的位置（单位：字符）</span><br><span class="line">set sidescrolloff&#x3D;15</span><br><span class="line"></span><br><span class="line">&quot; 不创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.</span><br><span class="line">set noswapfile</span><br><span class="line"></span><br><span class="line">&quot; 出错时，不要发出响声</span><br><span class="line">set noerrorbells</span><br><span class="line"></span><br><span class="line">&quot; 出错时，发出视觉提示，通常是屏幕闪烁</span><br><span class="line">set visualbell</span><br><span class="line"></span><br><span class="line">&quot; Vim 需要记住多少次历史操作</span><br><span class="line">set history&#x3D;1000</span><br><span class="line"></span><br><span class="line">&quot; 打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示</span><br><span class="line">set autoread</span><br><span class="line"></span><br><span class="line">&quot; 如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块</span><br><span class="line">set listchars&#x3D;tab:»■,trail:■</span><br><span class="line">set list</span><br><span class="line"></span><br><span class="line">&quot; 命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令</span><br><span class="line">set wildmenu</span><br><span class="line">set wildmode&#x3D;longest:list,full</span><br><span class="line"></span><br><span class="line">&quot; 启用256色</span><br><span class="line">set t_Co&#x3D;256</span><br><span class="line"></span><br><span class="line">&quot; 不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）</span><br><span class="line">set nobackup</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;pycharm&lt;/code&gt;和&lt;code&gt;jupyter notebook&lt;/code&gt;是我的主要coding工具，但偶尔也免不了直接在终端进行编辑，所以根据自己的需求和使用习惯对vim配置做了如下简单的调整：&lt;/p&gt;
&lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="vim" scheme="https://actionou.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Github添加SSH KEY</title>
    <link href="https://actionou.github.io/2019/01/30/github-add-ssh-key/"/>
    <id>https://actionou.github.io/2019/01/30/github-add-ssh-key/</id>
    <published>2019-01-30T10:31:51.000Z</published>
    <updated>2020-12-02T14:53:37.474Z</updated>
    
    <content type="html"><![CDATA[<p>对开发人员来说，SSH密钥在很多场景都要用到，而大多数人在不同平台使用同一个密钥对，比如公司代码仓库、公司服务器、个人服务器、甚至多个GitHub账号等等。<br>个人建议是每个平台使用专门的密钥对，并好好存档管理。</p><h2 id="1、生成一个GitHub专用的密钥对"><a href="#1、生成一个GitHub专用的密钥对" class="headerlink" title="1、生成一个GitHub专用的密钥对"></a>1、生成一个GitHub专用的密钥对</h2><p>比如GitHub用户名为<code>xyz</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.ssh; <span class="built_in">cd</span> ~/.ssh; ssh-keygen -t rsa -f id_github_xyz -C <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2、设置秘钥对文件权限"><a href="#2、设置秘钥对文件权限" class="headerlink" title="2、设置秘钥对文件权限"></a>2、设置秘钥对文件权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 id_github_xyz id_github_xyz.pub</span><br></pre></td></tr></table></figure><h2 id="3、把SSH-KEY添加到GitHub管理后台"><a href="#3、把SSH-KEY添加到GitHub管理后台" class="headerlink" title="3、把SSH KEY添加到GitHub管理后台"></a>3、把SSH KEY添加到GitHub管理后台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_github_xyz.pub</span><br></pre></td></tr></table></figure><p>访问<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>，将上面公钥的内容添加进去。</p><h2 id="4、配置本地GitHub账号别名"><a href="#4、配置本地GitHub账号别名" class="headerlink" title="4、配置本地GitHub账号别名"></a>4、配置本地GitHub账号别名</h2><p>编辑<code>~/.ssh/config</code>文件，添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github_xyz</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_github_xyz</span><br></pre></td></tr></table></figure><h2 id="5、使用ssh-agent管理生成的私钥"><a href="#5、使用ssh-agent管理生成的私钥" class="headerlink" title="5、使用ssh-agent管理生成的私钥"></a>5、使用ssh-agent管理生成的私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash &amp;&amp; ssh-add id_github_xyz</span><br></pre></td></tr></table></figure><h2 id="6、从远程仓库克隆"><a href="#6、从远程仓库克隆" class="headerlink" title="6、从远程仓库克隆"></a>6、从远程仓库克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> github_xyz:xyz/repository-name.git</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对开发人员来说，SSH密钥在很多场景都要用到，而大多数人在不同平台使用同一个密钥对，比如公司代码仓库、公司服务器、个人服务器、甚至多个GitHub账号等等。&lt;br&gt;个人建议是每个平台使用专门的密钥对，并好好存档管理。&lt;/p&gt;
&lt;h2 id=&quot;1、生成一个GitHub专用的密</summary>
      
    
    
    
    
    <category term="github" scheme="https://actionou.github.io/tags/github/"/>
    
    <category term="ssh" scheme="https://actionou.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://actionou.github.io/1970/01/01/hello-world/"/>
    <id>https://actionou.github.io/1970/01/01/hello-world/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-12-01T15:29:25.284Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://actionou.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
