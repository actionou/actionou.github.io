<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>actionou.github.io</title>
  
  
  <link href="https://actionou.github.io/atom.xml" rel="self"/>
  
  <link href="https://actionou.github.io/"/>
  <updated>2020-12-02T15:46:14.263Z</updated>
  <id>https://actionou.github.io/</id>
  
  <author>
    <name>actionou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何用数据分析思维解决实际问题？</title>
    <link href="https://actionou.github.io/2020/04/02/use-data-analysis-solve-practical-problems/"/>
    <id>https://actionou.github.io/2020/04/02/use-data-analysis-solve-practical-problems/</id>
    <published>2020-04-02T15:36:17.000Z</published>
    <updated>2020-12-02T15:46:14.263Z</updated>
    
    <content type="html"><![CDATA[<p>用户分析是电商数据分析中重要的模块，在对用户特征深度理解和用户需求充分挖掘基础上，进行全生命周期的运营管理（拉新—&gt;活跃—&gt;留存—&gt;价值提升—&gt;忠诚），请尝试回答以下3个问题：</p><p>① 用户第一单购买的行为往往反映了用户对平台的信任度和消费能力。现在数据库中有一张用户交易表order，其中有userid（用户ID）、amount（消费金额）、paytime（支付时间），请写出对应的SQL语句，查出每个用户第一单的消费金额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查出每个用户第一单的消费金额</span></span><br><span class="line"><span class="comment">--使用窗口函数(考虑一个用户不能同时下两单)</span></span><br><span class="line"><span class="keyword">select</span> a.userid,a.amount</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> * ,<span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> paytime) <span class="keyword">as</span> paytime_rank <span class="keyword">from</span> <span class="keyword">order</span> ) <span class="keyword">as</span> </span><br><span class="line">a <span class="keyword">where</span> paytime_rank=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--使用联结方法</span></span><br><span class="line"><span class="comment">--查出第一单消费时间</span></span><br><span class="line">creat <span class="keyword">view</span> t <span class="keyword">as</span></span><br><span class="line">(<span class="keyword">select</span> userid, <span class="keyword">min</span>(paytime) <span class="keyword">as</span> 首次消费时间 <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">group</span> <span class="keyword">by</span> userid)</span><br><span class="line"><span class="comment">--找出第一消费金额</span></span><br><span class="line"><span class="keyword">select</span> t.userid,t.首次消费时间 ,b.amount <span class="keyword">from</span> t <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> (t.userid=b.userid <span class="keyword">and</span> t.首次消费时间=b.paytime)</span><br></pre></td></tr></table></figure><p>② 当你发现本月的支付用户数环比上月大幅下跌（超30%），你会如何去探查背后的原因？请描述你的思路和其中涉及的关键指标。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_a372e778e2bcf40c99f03c37d16a74ed.png" alt="image.png"></p><p><strong>第一步：明确问题</strong></p><ul><li>明确数据<strong>来源和准确性</strong>：时间是本月，对比的基准是上月，地点是哪个城市的支付用户还是所有的支付用户?数据来源哪个部门，数据是否无误，</li><li><strong>业务指标</strong>理解：支付用户数=用户数*转化率 。明确是和上月对比下跌超过30%，运用多维度拆解分析方法，把整体拆成部分，查看内部的差异。</li></ul><p><strong>第二步：分析原因</strong></p><p>使用多维度拆解分析方法对支付用户数这个指标进行拆解：<strong>支付用户数=用户数*转化率</strong></p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_067cba2f944a054de9def4e0cbca28f8.png" alt="image.png"></p><p>从<strong>新老用户维度进行拆解</strong>，把用户数拆解成新用户数和老用户活跃人数，其中新用户数在平台购买过的用户人数，老用户活跃人数是在平台购买过的用户在平台活跃的人数。</p><p>新用户数按渠道维度，又继续拆解为渠道A新用户，渠道B新用户等，考虑不同渠道的转化率也可能不一样，同样分渠道拆解为渠道A转化率，渠道B转化率，渠道C转化率。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_304cdfc65cd9e493916d35565e9ac08f.png" alt="image.png"></p><p>对以上分析 做出<strong>假设一：渠道A、B、C新用户人数减少</strong></p><p>收集证据，分析渠道投放效果。使用<strong>对比分析方法</strong>，如果确认某渠道用户相比上月确实降低则对渠道用户数进行多维度拆解，可以<strong>从年龄构成拆分，性别构成拆分，职业结构拆分和地域组成拆分，分别进行假设检验</strong>，手机证据，将渠道人数降低定位到是那个人群用户数降低，渠道的导入量降低的原因，分析渠道投放是否有效。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_8fd68f327d7b122f4a458b54f6a9daef.png" alt="image.png"></p><p>继续考虑用户数 <strong>假设二：渠道A、B、C转化率降低</strong></p><p>使用对比分析如果确认某渠道转化率降低，继续按业务流程对该渠道具体哪一步出现的问题进行拆解，假设平台用户的流程有广告、进店、选择商品、购买。</p><p>则按业务流程拆解如下，通过<strong>假设检验</strong>，收集数据，查看产品板块是否更新，询问客服是否有投诉，有页面崩溃，不能成功下单导致某一环节流失率高，闪退，使用漏斗模型，判断是哪个产品环节出了问题。<strong>使用假设检验，验证每个环节的假设。</strong></p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_dc66f68108cf68059da2b219e9f2be9b.png" alt="image.png"></p><p><strong>假设三：老用户活跃人数出了问题</strong></p><p>通过假设检验和对比分析方法分析老用户活跃人数是否降低，如果降低的话，思考老用户活跃人数为什么会降低呢？我们从<strong>用户、产品、竞品</strong>三个维度分析原因。</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_c2daaa1ed112a705864456766d7f9f8c.png" alt="image.png"></p><p><strong>1.</strong> 用户购买体验不好，产品描述与实际不符</p><p><strong>2.</strong> 产品售后服务不够好等</p><p><strong>3.</strong> 上月做活动，上月活跃人数大幅上涨等</p><p><strong>4.</strong> 竞品在搞活动，用户被对手吸引</p><p>可以分别从几个假设去分析原因,如果以上三大部分假设有问题，总结原因如下：</p><ul><li><strong>原始渠道A用户发生改变，</strong>导致渠道导入量下降，具体表现20-35岁年龄段人数下降，该35-50人群年龄段占比上升，而20-30岁群体是为我们平台的主要使用人群。</li><li><strong>产品更新迭代，</strong>用户习惯之前的界面，还没有适应</li><li><strong>由于之前平台大促</strong>，导致平台的售后和产品质量方面波动较大，用户颇为不满</li></ul><p>总结<strong>新用户引入不够，老用户留存没做好，产品本身改动，</strong>导致出现了这种大幅下跌的情况。</p><p><strong>第三步：提出建议</strong></p><p>针对以上的分析提出以下建议：</p><ul><li><strong>渠道A用户人群转移</strong>，考虑撤回渠道投放或者修改投放内容，吸引35-50岁人群用户进入平台，提高转化</li><li>用户使用体验不佳，建议<strong>对部分用户推更新版本</strong>，建立对照组，进行AB测试</li><li><strong>从平台的评论，对于中差评老用户进行回访</strong>，明确原因，进行挽回。</li></ul><p>③ 为了更好的理解用户，我们通常会基于用户的特征对用户进行分类，便于更加精细化的理解用户，设计产品和运营玩法，请你设计对应的聚类方法，包括重点的用户特征的选择及聚类算法并说明其基本原理和步骤。</p><p><strong>1. K-means聚类</strong></p><p>使用K-means聚类的好处是可以加入性别，地域，薪资等特征，这样就可以得到的分类的年龄分布情况，薪资情况，职业分布等情况，<strong>比RFM会信息更多，但类别的解释性没有RFM用户分层强</strong></p><p><strong>特征选择</strong>：人口统计学特征（性别，地域 ,年龄，薪资，职业，家庭成员)，用户分层特征（消费频率，平均消费金额，最近一次消费时间）产品特征(购买物品类别)</p><p><strong>基本原理</strong>：</p><p>step1：选举K个对象作为初始的聚类中心；</p><p>step2：计算每个对象与各种子聚类中心间的欧式距离，把每个对象分配给他最近的聚类中心；</p><p>step3：一旦全部对象被分配了，每个聚类的聚类中心会根据聚类中现有的对象被重新计算，重新分配。依次循环，直到聚类中心点不再改变时循环结束。</p><p><strong>2. RFM分层</strong></p><p>根据业务需求，使用RFM对用户进行分层，使用RFM的好处是<strong>得到的类别结果具有更明确的实际业务意义</strong>，能指导精细化运营。<strong>缺点是没有考虑用户的人口统计学特征。</strong></p><p>主要得到分层结果重要（一般）价值、发展、挽留、保持客户八类</p><p>step1：计算RFM值（消费频率，平均消费金额，最近一次消费时间）</p><p>step2：分别RFM进行打分，确定打分体系，按价值打分,，计算均值或中值,超过均值/中值则该项指标分类为高，低于均值则该指标分类为低，</p><p>step3：进行用户分类，根据用户分类规则找到是否高低</p><p>step4：对应表格找到用户属于哪个分类</p><p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_3ae8a7ebdb35ad2d8c28bd147af542e7.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用户分析是电商数据分析中重要的模块，在对用户特征深度理解和用户需求充分挖掘基础上，进行全生命周期的运营管理（拉新—&amp;gt;活跃—&amp;gt;留存—&amp;gt;价值提升—&amp;gt;忠诚），请尝试回答以下3个问题：&lt;/p&gt;
&lt;p&gt;① 用户第一单购买的行为往往反映了用户对平台的信任度和消费</summary>
      
    
    
    
    
    <category term="python" scheme="https://actionou.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>写出优雅的Python代码之—仓库结构（译）</title>
    <link href="https://actionou.github.io/2020/01/10/great-python-code-structure/"/>
    <id>https://actionou.github.io/2020/01/10/great-python-code-structure/</id>
    <published>2020-01-10T11:55:22.000Z</published>
    <updated>2020-12-02T15:11:35.487Z</updated>
    
    <content type="html"><![CDATA[<p>我们对于“结构化”的定义是您关注于怎样使您的项目最好地满足它的对象性，我们需要去考虑如何更好地利用Python的特性来创造简洁、高效的代码。在实践层面， “结构化”意味着通过编写简洁的代码，并且正如文件系统中文件和目录的组织一样，代码应该使逻辑和依赖清晰。</p><p>哪个函数应该深入到哪个模块？数据在项目中如何流转？什么功能和函数应该组合或独立？要解决这些问题，您可以开始做一个计划，大体来说，即是您的最终产品看起来会是怎样的。</p><p>在这一章节中，我们更深入地去观察Python的模块和导入系统，因为它们是加强您的项目结构化的关键因素，接着我们会从不同层面去讨论如何去构建可扩展且测试可靠的的代码。</p><h2 id="仓库结构很重要"><a href="#仓库结构很重要" class="headerlink" title="仓库结构很重要"></a>仓库结构很重要</h2><p>在一个健康的开发周期中，代码风格、API设计和自动化是非常关键的。同样的，对于项目架构，仓库的结构也是关键的一部分。</p><p>当一个潜在的用户和代码贡献者访问您的代码仓库时，他们会看到这些:</p><ul><li>工程的名字</li><li>工程的描述</li><li>一系列的文件</li></ul><p>只有当他们滚动到目录下方时才会看到您工程的README。</p><p>如果您的仓库的目录一团糟，没有清晰的结构，他们可能要到处寻找才能发现您写的<strong>漂亮</strong>的文档。</p><blockquote><p>为您渴望的事业而奋斗，而不仅仅只是为您现在的工作而工作。</p></blockquote><p>当然，第一印象并不决定一切。但是，您和您的同事会和这个仓库并肩战斗很长时间，会接触它的每一个角落和细节。拥有良好的布局，事半功倍。</p><h2 id="仓库样例"><a href="#仓库样例" class="headerlink" title="仓库样例"></a>仓库样例</h2><p>请看这里: 这是 <a href="http://kennethreitz.org/">Kenneth Reitz</a> 推荐的。<br>这个项目可以在GitHub上找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">LICENSE</span><br><span class="line">setup.py</span><br><span class="line">requirements.txt</span><br><span class="line">sample&#x2F;__init__.py</span><br><span class="line">sample&#x2F;core.py</span><br><span class="line">sample&#x2F;helpers.py</span><br><span class="line">docs&#x2F;conf.py</span><br><span class="line">docs&#x2F;index.rst</span><br><span class="line">tests&#x2F;test_basic.py</span><br><span class="line">tests&#x2F;test_advanced.py</span><br></pre></td></tr></table></figure><p>让我们再继续看一些细节。</p><h2 id="真正的模块"><a href="#真正的模块" class="headerlink" title="真正的模块"></a>真正的模块</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./sample/</code> or <code>./sample.py</code></td><td align="center">核心代码</td></tr></tbody></table><p>您的模块包是这个仓库的核心，它不应该隐藏起来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;sample&#x2F;</span><br></pre></td></tr></table></figure><p>如果您的模块只有一个文件，那么您可以直接将这个文件放在仓库的根目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;sample.py</span><br></pre></td></tr></table></figure><p>这个模块文件不应该属于任何一个模棱两可的src或者python子目录。</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left">./LICENSE</td><td align="center">许可证</td></tr></tbody></table><p>除了源代码本身以外，这个毫无疑问是您仓库最重要的一部分。在这个文件中要有完整的许可说明和授权。<br>如果您不太清楚您应该使用哪种许可方式，请查看 <a href="http://choosealicense.com/">choosealicense.com</a>.<br>当然，您也可以在发布您的代码时不做任何许可说明，但是这显然阻碍潜在的用户使用您的代码。</p><h2 id="Setup-py"><a href="#Setup-py" class="headerlink" title="Setup.py"></a>Setup.py</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./setup.py</code></td><td align="center">打包和发布管理</td></tr></tbody></table><p>如果您的模块包在您的根目录下，显然这个文件也应该在根目录下。</p><h2 id="Requirements-File"><a href="#Requirements-File" class="headerlink" title="Requirements File"></a>Requirements File</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./requirements.txt</code></td><td align="center">开发依赖</td></tr></tbody></table><p>一个 <a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files">pip requirements file</a> 应该放在仓库的根目录。它应该指明完整工程的所有依赖包: 测试, 编译和文档生成。</p><p>如果您的工程没有任何开发依赖，或者您喜欢通过<code>setup.py</code>来设置，那么这个文件不是必须的。</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./docs/</code></td><td align="center">包的参考文档</td></tr></tbody></table><p>没有任何理由把这个放到别的地方。</p><h2 id="Test-Suite"><a href="#Test-Suite" class="headerlink" title="Test Suite"></a>Test Suite</h2><p>想了解关于编写测试的建议，请查阅 <a href="https://docs.python-guide.org/writing/tests/">Testing Your Code</a>.</p><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./test_sample.py</code> or <code>./tests</code></td><td align="center">包的集合和单元测试</td></tr></tbody></table><p>最开始，一组测试例子只是放在一个文件当中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;test_sample.py</span><br></pre></td></tr></table></figure><p>当测试例子逐步增加时，您会把它放到一个目录里面，像下面这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tests&#x2F;test_basic.py</span><br><span class="line">tests&#x2F;test_advanced.py</span><br></pre></td></tr></table></figure><p>当然，这些测试例子需要导入您的包来进行测试，有几种方式来处理:</p><ul><li>将您的包安装到site-packages中。</li><li>通过简单直接的路径设置来解决导入的问题。</li></ul><p>我极力推荐后者。如果使用<code>setup.py develop</code>来测试一个持续更新的代码库，需要为每一个版本的代码库设置一个独立的测试环境.太麻烦了。</p><p>可以先创建一个包含上下文环境的文件<code>tests/context.py</code>。 file:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, os.path.abspath(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;..&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sample</span><br></pre></td></tr></table></figure><p>然后，在每一个测试文件中，导入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .context <span class="keyword">import</span> sample</span><br></pre></td></tr></table></figure><p>这样就能够像期待的那样工作，而不用采用安装的方式。</p><p>一些人会说应该把您的测试例子放到您的模块里面。我不同意。这样会增加您用户使用的复杂度；而且添加测试模块将导致需要额外的依赖和运行环境。</p><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><table><thead><tr><th align="left">布局</th><th align="center">作用</th></tr></thead><tbody><tr><td align="left"><code>./Makefile</code></td><td align="center">常规的管理任务</td></tr></tbody></table><p>如果您看看我的项目或者其他开源项目，您都会发现有一个Makefile。为什么？这些项目也不是用C写的啊。。。简而言之，make对于定义常规的管理任务是非常有用的工具。</p><p><strong>样例 Makefile:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init:</span><br><span class="line">    pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">    py.test tests</span><br><span class="line"></span><br><span class="line">.PHONY: init test</span><br></pre></td></tr></table></figure><p>一些其他的常规管理脚本（比如<code>manage.py</code>或者<code>fabfile.py</code>），也放在仓库的根目录下。</p><h2 id="关于-Django-Applications"><a href="#关于-Django-Applications" class="headerlink" title="关于 Django Applications"></a>关于 Django Applications</h2><p>从Django 1.4开始，有这样一个现象：很多开发者错误地使用Django自带的应用模板创建项目，导致他们的仓库结构非常糟糕。</p><p>这是怎么回事呢? 原来, 他们在创建一个新的仓库后通常都这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite</span><br></pre></td></tr></table></figure><p>这样子操作生成的仓库结构是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">samplesite&#x2F;manage.py</span><br><span class="line">samplesite&#x2F;samplesite&#x2F;settings.py</span><br><span class="line">samplesite&#x2F;samplesite&#x2F;wsgi.py</span><br><span class="line">samplesite&#x2F;samplesite&#x2F;sampleapp&#x2F;models.py</span><br></pre></td></tr></table></figure><p>亲，不要这样做。</p><p>相对路径会让您的工具和您的开发者都很疑惑。没有必要的嵌套对任何人都没有好处（除非您怀念庞大的SVN仓库）。</p><p>让我们这样来做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin.py startproject samplesite .</span><br></pre></td></tr></table></figure><p>注意末尾的”<code>.</code>“。</p><p>生成的结构是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.rst</span><br><span class="line">manage.py</span><br><span class="line">samplesite&#x2F;settings.py</span><br><span class="line">samplesite&#x2F;wsgi.py</span><br><span class="line">samplesite&#x2F;sampleapp&#x2F;models.py</span><br></pre></td></tr></table></figure><blockquote><p>END</p></blockquote><hr><p>翻译自 <a href="https://docs.python-guide.org/writing/structure/">https://docs.python-guide.org/writing/structure/</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们对于“结构化”的定义是您关注于怎样使您的项目最好地满足它的对象性，我们需要去考虑如何更好地利用Python的特性来创造简洁、高效的代码。在实践层面， “结构化”意味着通过编写简洁的代码，并且正如文件系统中文件和目录的组织一样，代码应该使逻辑和依赖清晰。&lt;/p&gt;
&lt;p&gt;哪</summary>
      
    
    
    
    
    <category term="python" scheme="https://actionou.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python中的单例模式</title>
    <link href="https://actionou.github.io/2019/12/02/python-singleton/"/>
    <id>https://actionou.github.io/2019/12/02/python-singleton/</id>
    <published>2019-12-02T14:50:20.000Z</published>
    <updated>2020-12-02T15:11:47.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>​单例模式<code>Singleton Pattern</code>是一种常用的<strong>软件设计模式</strong>，该模式的主要目的是确保某一个类只有一个实例存在。</p><p><strong>拓展</strong>：软件设计模式<br>在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。<br>refer:<a href="http://c.biancheng.net/view/1320.html">http://c.biancheng.net/view/1320.html</a></p><table><thead><tr><th>范围\目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法</td><td>(类)适配器</td><td>模板方法、解释器</td></tr><tr><td>对象模式</td><td>单例<br/>原型<br/>抽象工厂<br/>建造者</td><td>代理<br/>(对象)适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/>组合</td><td>策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器<br/>访问者<br/>备忘录</td></tr></tbody></table><h2 id="Python中实现单例模式的方法"><a href="#Python中实现单例模式的方法" class="headerlink" title="Python中实现单例模式的方法"></a>Python中实现单例模式的方法</h2><h3 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1.使用模块"></a>1.使用模块</h3><p><strong>即文件导入的形式：</strong><br>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p><p><strong>pyc是什么文件?</strong><br>pyc是一种二进制文件，是由py文件经过编译后，生成的文件，是一种byte code，py文件变成pyc文件后，运行加载的速度会有所提高；另一反面，把py文件编译为pyc文件，从而可以实现部分的源码隐藏，保证了python做商业化软件时的安全性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s1.py 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># v是Foo的实例</span></span><br><span class="line">foo = Foo()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s2.py 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> s1 <span class="keyword">import</span> foo <span class="keyword">as</span> f1</span><br><span class="line">print(f1,<span class="built_in">id</span>(f1))  <span class="comment">#&lt;s1.Foo object at 0x0000000002221710&gt;  35788560</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> s1 <span class="keyword">import</span> foo <span class="keyword">as</span> f2</span><br><span class="line">print(f2,<span class="built_in">id</span>(f2))   <span class="comment">#&lt;s1.Foo object at 0x0000000002221710&gt;  35788560</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个的内存地址是一样的</span></span><br><span class="line"><span class="comment"># 第一次导入后，再次导入时不会再重新加载，而是直接加载.pyc文件</span></span><br></pre></td></tr></table></figure><h3 id="2-基于-new-方法实现的单例模式"><a href="#2-基于-new-方法实现的单例模式" class="headerlink" title="2.基于__new__方法实现的单例模式"></a>2.基于__new__方法实现的单例模式</h3><p>当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__）实例化对象；然后再执行类的__init__方法，对这个对象进行初始化等操作，<br>所以我们可以基于这个，对__new__方法做一些手脚，实现单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;基于__new__方法一&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __new__(cls):</span><br><span class="line">        # 这个函数是判断指定对象中是否有某属性，内部实现是调用了getattr()，并捕获AttributeError异常。</span><br><span class="line">        # 利用反射看看这个类有没有instance属性</span><br><span class="line">        if not hasattr(cls, &#39;instance&#39;):</span><br><span class="line">            # 调用 __new__ 方法申请内存</span><br><span class="line">            # 如果不重写 __new__ 方法，会调用 object 的 __new__方法申请内存</span><br><span class="line">            # 如果重写了 __new__ 方法，需要自己手动的申请内存</span><br><span class="line">            cls.instance &#x3D; super(Foo, cls).__new__(cls)</span><br><span class="line">        return cls.instance</span><br></pre></td></tr></table></figure><p><strong>什么是反射？</strong><br>在面向对象的思想中，把对象能够访问、查询、修改自身的状态或行为称为“反射”。</p><p><strong>python中的反射</strong><br>在python中，可以通过字符串的的形式来操作对象的属性。这种行为称之为python中的反射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============基于__new__方法二=============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 定义一个类属性，用来保存实例化的对象</span></span><br><span class="line">    <span class="comment"># 私有类属性</span></span><br><span class="line">    __instance = <span class="literal">None</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 1.判断类属性是否为空</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 2.调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.__instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">            print(cls.__instance)</span><br><span class="line">        <span class="comment"># 3.返回类属性保存的对象的应用</span></span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br></pre></td></tr></table></figure><h3 id="3-使用类方法"><a href="#3-使用类方法" class="headerlink" title="3.使用类方法"></a>3.使用类方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路就是,调用类的instance方法,这样有一个弊端就是在使用类创建的时候,并不是单例了.也就是说在创建类的时候一定要用类里面规定的方法创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 利用反射 看看这个类有没有_instance属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">s1 = Singleton()  <span class="comment"># 这样创建的对象并不是单例</span></span><br><span class="line">s2 = Singleton.get_instance() <span class="comment"># 要调用特定的方法创建单例对象</span></span><br></pre></td></tr></table></figure><h3 id="4-使用装饰器-推荐使用"><a href="#4-使用装饰器-推荐使用" class="headerlink" title="4.使用装饰器(推荐使用)"></a>4.使用装饰器(推荐使用)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============函数装饰器=============</span></span><br><span class="line"><span class="comment"># 1.把类当成函数传递给装饰器</span></span><br><span class="line"><span class="comment"># 2.创建类的实例的时候调用Foo已经变成了调用inner。</span></span><br><span class="line"><span class="comment"># 3.在inner内部实现单例类的创建</span></span><br><span class="line"><span class="comment"># 4.因此foo1、foo2的值都等于inner返回值。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">fun</span>):</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">if</span> fun <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            <span class="comment"># 使用不可变的类地址作为键，其实例作为值，</span></span><br><span class="line">            <span class="comment"># 每次创造实例时，首先查看该类是否存在实例，</span></span><br><span class="line">            <span class="comment"># 存在的话直接返回该实例即可，</span></span><br><span class="line">            <span class="comment"># 否则新建一个实例并存放在字典中。</span></span><br><span class="line">            _instance[fun] = fun()</span><br><span class="line">        <span class="keyword">return</span> _instance[fun]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(foo1 <span class="keyword">is</span> foo2)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===========类装饰器============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        self.cls = cls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            Singleton._instance = self.cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="comment"># Demo已经变了，Demo已经是Singleton的实例了，在Singleton里面加入了__call__方法，让实例可以被调用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">do1 = Demo()</span><br><span class="line">do2 = Demo()</span><br><span class="line">print(<span class="built_in">id</span>(do1), <span class="built_in">id</span>(do2))</span><br></pre></td></tr></table></figure><h3 id="5-共享属性（不推荐使用）"><a href="#5-共享属性（不推荐使用）" class="headerlink" title="5.共享属性（不推荐使用）"></a>5.共享属性（不推荐使用）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)  </span></span><br><span class="line"><span class="comment">#同一个类的所有实例天然拥有相同的行为(方法),  </span></span><br><span class="line"><span class="comment">#只需要保证同一个类的所有实例具有相同的状态(属性)即可  </span></span><br><span class="line"><span class="comment">#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        ob = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span>(<span class="params">Singleton</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;最后的结果是<span class="subst">&#123;self.name&#125;</span>&#x27;</span>) <span class="comment"># 实例化N个对象打印的都是最后创建的对象的name属性</span></span><br></pre></td></tr></table></figure><h3 id="6-基于metaclass-元类-实现的单例模式"><a href="#6-基于metaclass-元类-实现的单例模式" class="headerlink" title="6.基于metaclass(元类)实现的单例模式"></a>6.基于metaclass(元类)实现的单例模式</h3><p><strong>什么是元类？</strong><br>实例对象是由类来创建，那么类又是由什么来创建的呢？ 答案就是元类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            cls._instance = <span class="built_in">super</span>(SingletonType, cls).__call__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)</span></span><br><span class="line"><span class="comment"># metaclass=SingletonType 这样就表示调用SingletonType的__call__方法来创建Foo类</span></span><br><span class="line"><span class="comment"># 判断实例化的对象是否有_instance这个属性</span></span><br><span class="line"><span class="comment"># 然后调用父类type的__call__方法创建Foo对象(类)</span></span><br><span class="line"><span class="comment"># 同时Foo创建了就会调用Foo类的__new__方法和__init__方法实例化对象</span></span><br><span class="line"><span class="comment"># 返回这个实例化对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonType</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Foo(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">obj2 = Foo(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line">print(obj1, obj2)</span><br><span class="line">print(<span class="built_in">id</span>(obj1), <span class="built_in">id</span>(obj2))</span><br></pre></td></tr></table></figure><p>元类实现单例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonMeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">cls,*args, **kwargs</span>):</span></span><br><span class="line">    <span class="comment"># 这个self是指定了使用SingletonMeta作为元类的类对应的对象</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        cls.__instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了metaclass=type的话，就会实现单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">President</span>(<span class="params"><span class="built_in">object</span>, metaclass=<span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">President() <span class="comment"># 这个类是SingletonMeta创建出的对象，那么在类后面加()，相当于调用了元类(type)的__call__魔术方法。所以可以在__call__里面做文章，来实现单例。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了metaclass=type的话，就会实现单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonMeta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h2&gt;&lt;p&gt;​单例模式&lt;code&gt;Singleton Pattern&lt;/code&gt;是一种常用的&lt;strong&gt;软</summary>
      
    
    
    
    
    <category term="python" scheme="https://actionou.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>vimrc</title>
    <link href="https://actionou.github.io/2019/07/01/vimrc/"/>
    <id>https://actionou.github.io/2019/07/01/vimrc/</id>
    <published>2019-07-01T15:26:01.000Z</published>
    <updated>2020-12-02T14:54:03.307Z</updated>
    
    <content type="html"><![CDATA[<p><code>pycharm</code>和<code>jupyter notebook</code>是我的主要coding工具，但偶尔也免不了直接在终端进行编辑，所以根据自己的需求和使用习惯对vim配置做了如下简单的调整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">&quot; 使用 utf-8 编码</span><br><span class="line">set encoding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">&quot; 去掉有关vi一致性模式,避免操作习惯上的局限.</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; 让Backspace键可以往前删除字符.</span><br><span class="line">set backspace&#x3D;indent,eol,start</span><br><span class="line"></span><br><span class="line">&quot; 总是显示状态行</span><br><span class="line">set laststatus&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; 在状态栏显示光标的当前位置（位于哪一行哪一列）</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">&quot; 显示还没有输入完整的命令.例如yy命令,输入第一个y会在右下角显示y.</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 关闭自动折行</span><br><span class="line">set nowrap</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示所有搜索到的内容</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 光标立刻跳转到搜索到内容</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot; 搜索时忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 搜索到最后匹配的位置后,再次搜索不回到第一个匹配处</span><br><span class="line">set nowrapscan</span><br><span class="line"></span><br><span class="line">&quot; 设置Esc超时时间为100ms,尽快生效</span><br><span class="line">set ttimeout</span><br><span class="line">set ttimeoutlen&#x3D;100</span><br><span class="line"></span><br><span class="line">&quot; 高亮光标所在的行</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">&quot; 开启语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 在底部显示，当前处于命令模式还是插入模式</span><br><span class="line">set showmode</span><br><span class="line"></span><br><span class="line">&quot; 命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">&quot; 检测文件类型,并载入文件类型插件,为特定文件类型载入相关缩进文件</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 按下 Tab 键时，Vim 显示的空格数</span><br><span class="line">set tabstop&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; 在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者&#x3D;&#x3D;（取消全部缩进）时，每一级的字符数</span><br><span class="line">set shiftwidth&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; 输入Tab字符时,自动替换成空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot; 设置softtabstop有一个好处是可以用Backspace键来一次删除4个空格.</span><br><span class="line">&quot; softtabstop的值为负数,会使用shiftwidth的值,两者保持一致,方便统一缩进.</span><br><span class="line">set softtabstop&#x3D;-1</span><br><span class="line"></span><br><span class="line">&quot; 使用 utf-8 编码</span><br><span class="line">set encoding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">&quot; 垂直滚动时，光标距离顶部&#x2F;底部的位置（单位：行）</span><br><span class="line">set scrolloff&#x3D;5</span><br><span class="line"></span><br><span class="line">&quot; 水平滚动时，光标距离行首或行尾的位置（单位：字符）</span><br><span class="line">set sidescrolloff&#x3D;15</span><br><span class="line"></span><br><span class="line">&quot; 不创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.</span><br><span class="line">set noswapfile</span><br><span class="line"></span><br><span class="line">&quot; 出错时，不要发出响声</span><br><span class="line">set noerrorbells</span><br><span class="line"></span><br><span class="line">&quot; 出错时，发出视觉提示，通常是屏幕闪烁</span><br><span class="line">set visualbell</span><br><span class="line"></span><br><span class="line">&quot; Vim 需要记住多少次历史操作</span><br><span class="line">set history&#x3D;1000</span><br><span class="line"></span><br><span class="line">&quot; 打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示</span><br><span class="line">set autoread</span><br><span class="line"></span><br><span class="line">&quot; 如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块</span><br><span class="line">set listchars&#x3D;tab:»■,trail:■</span><br><span class="line">set list</span><br><span class="line"></span><br><span class="line">&quot; 命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令</span><br><span class="line">set wildmenu</span><br><span class="line">set wildmode&#x3D;longest:list,full</span><br><span class="line"></span><br><span class="line">&quot; 启用256色</span><br><span class="line">set t_Co&#x3D;256</span><br><span class="line"></span><br><span class="line">&quot; 不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）</span><br><span class="line">set nobackup</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;pycharm&lt;/code&gt;和&lt;code&gt;jupyter notebook&lt;/code&gt;是我的主要coding工具，但偶尔也免不了直接在终端进行编辑，所以根据自己的需求和使用习惯对vim配置做了如下简单的调整：&lt;/p&gt;
&lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="vim" scheme="https://actionou.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Github添加SSH KEY</title>
    <link href="https://actionou.github.io/2019/01/30/github-add-ssh-key/"/>
    <id>https://actionou.github.io/2019/01/30/github-add-ssh-key/</id>
    <published>2019-01-30T10:31:51.000Z</published>
    <updated>2020-12-02T14:53:37.474Z</updated>
    
    <content type="html"><![CDATA[<p>对开发人员来说，SSH密钥在很多场景都要用到，而大多数人在不同平台使用同一个密钥对，比如公司代码仓库、公司服务器、个人服务器、甚至多个GitHub账号等等。<br>个人建议是每个平台使用专门的密钥对，并好好存档管理。</p><h2 id="1、生成一个GitHub专用的密钥对"><a href="#1、生成一个GitHub专用的密钥对" class="headerlink" title="1、生成一个GitHub专用的密钥对"></a>1、生成一个GitHub专用的密钥对</h2><p>比如GitHub用户名为<code>xyz</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.ssh; <span class="built_in">cd</span> ~/.ssh; ssh-keygen -t rsa -f id_github_xyz -C <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2、设置秘钥对文件权限"><a href="#2、设置秘钥对文件权限" class="headerlink" title="2、设置秘钥对文件权限"></a>2、设置秘钥对文件权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 id_github_xyz id_github_xyz.pub</span><br></pre></td></tr></table></figure><h2 id="3、把SSH-KEY添加到GitHub管理后台"><a href="#3、把SSH-KEY添加到GitHub管理后台" class="headerlink" title="3、把SSH KEY添加到GitHub管理后台"></a>3、把SSH KEY添加到GitHub管理后台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_github_xyz.pub</span><br></pre></td></tr></table></figure><p>访问<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>，将上面公钥的内容添加进去。</p><h2 id="4、配置本地GitHub账号别名"><a href="#4、配置本地GitHub账号别名" class="headerlink" title="4、配置本地GitHub账号别名"></a>4、配置本地GitHub账号别名</h2><p>编辑<code>~/.ssh/config</code>文件，添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github_xyz</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_github_xyz</span><br></pre></td></tr></table></figure><h2 id="5、使用ssh-agent管理生成的私钥"><a href="#5、使用ssh-agent管理生成的私钥" class="headerlink" title="5、使用ssh-agent管理生成的私钥"></a>5、使用ssh-agent管理生成的私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash &amp;&amp; ssh-add id_github_xyz</span><br></pre></td></tr></table></figure><h2 id="6、从远程仓库克隆"><a href="#6、从远程仓库克隆" class="headerlink" title="6、从远程仓库克隆"></a>6、从远程仓库克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> github_xyz:xyz/repository-name.git</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对开发人员来说，SSH密钥在很多场景都要用到，而大多数人在不同平台使用同一个密钥对，比如公司代码仓库、公司服务器、个人服务器、甚至多个GitHub账号等等。&lt;br&gt;个人建议是每个平台使用专门的密钥对，并好好存档管理。&lt;/p&gt;
&lt;h2 id=&quot;1、生成一个GitHub专用的密</summary>
      
    
    
    
    
    <category term="github" scheme="https://actionou.github.io/tags/github/"/>
    
    <category term="ssh" scheme="https://actionou.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://actionou.github.io/1970/01/01/hello-world/"/>
    <id>https://actionou.github.io/1970/01/01/hello-world/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2020-12-01T15:29:25.284Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://actionou.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
