<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Python中的单例模式 | actionou.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="什么是单例模式​单例模式Singleton Pattern是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。 拓展：软件设计模式在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。refer:http:&#x2F;&#x2F;c.biancheng.net&#x2F;view&#x2F;1320.html    范围\目的 创建型模式 结构型模式 行为型模式    类模式 工厂方法 (类)适配器 模板">
<meta property="og:type" content="article">
<meta property="og:title" content="Python中的单例模式">
<meta property="og:url" content="https://actionou.github.io/2019/12/02/python-singleton/index.html">
<meta property="og:site_name" content="actionou.github.io">
<meta property="og:description" content="什么是单例模式​单例模式Singleton Pattern是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。 拓展：软件设计模式在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。refer:http:&#x2F;&#x2F;c.biancheng.net&#x2F;view&#x2F;1320.html    范围\目的 创建型模式 结构型模式 行为型模式    类模式 工厂方法 (类)适配器 模板">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-12-02T14:50:20.000Z">
<meta property="article:modified_time" content="2020-12-02T15:11:47.276Z">
<meta property="article:author" content="actionou">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/images/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">actionou.github.io</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://actionou.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-python-singleton" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/02/python-singleton/" class="article-date">
  <time class="dt-published" datetime="2019-12-02T14:50:20.000Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Python中的单例模式
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>​单例模式<code>Singleton Pattern</code>是一种常用的<strong>软件设计模式</strong>，该模式的主要目的是确保某一个类只有一个实例存在。</p>
<p><strong>拓展</strong>：软件设计模式<br>在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。<br>refer:<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1320.html">http://c.biancheng.net/view/1320.html</a></p>
<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类)适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例<br/>原型<br/>抽象工厂<br/>建造者</td>
<td>代理<br/>(对象)适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/>组合</td>
<td>策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器<br/>访问者<br/>备忘录</td>
</tr>
</tbody></table>
<h2 id="Python中实现单例模式的方法"><a href="#Python中实现单例模式的方法" class="headerlink" title="Python中实现单例模式的方法"></a>Python中实现单例模式的方法</h2><h3 id="1-使用模块"><a href="#1-使用模块" class="headerlink" title="1.使用模块"></a>1.使用模块</h3><p><strong>即文件导入的形式：</strong><br>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。</p>
<p><strong>pyc是什么文件?</strong><br>pyc是一种二进制文件，是由py文件经过编译后，生成的文件，是一种byte code，py文件变成pyc文件后，运行加载的速度会有所提高；另一反面，把py文件编译为pyc文件，从而可以实现部分的源码隐藏，保证了python做商业化软件时的安全性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s1.py 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># v是Foo的实例</span></span><br><span class="line">foo = Foo()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s2.py 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> s1 <span class="keyword">import</span> foo <span class="keyword">as</span> f1</span><br><span class="line">print(f1,<span class="built_in">id</span>(f1))  <span class="comment">#&lt;s1.Foo object at 0x0000000002221710&gt;  35788560</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> s1 <span class="keyword">import</span> foo <span class="keyword">as</span> f2</span><br><span class="line">print(f2,<span class="built_in">id</span>(f2))   <span class="comment">#&lt;s1.Foo object at 0x0000000002221710&gt;  35788560</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个的内存地址是一样的</span></span><br><span class="line"><span class="comment"># 第一次导入后，再次导入时不会再重新加载，而是直接加载.pyc文件</span></span><br></pre></td></tr></table></figure>

<h3 id="2-基于-new-方法实现的单例模式"><a href="#2-基于-new-方法实现的单例模式" class="headerlink" title="2.基于__new__方法实现的单例模式"></a>2.基于__new__方法实现的单例模式</h3><p>当我们实例化一个对象时，是先执行了类的__new__方法（我们没写时，默认调用object.__new__）实例化对象；然后再执行类的__init__方法，对这个对象进行初始化等操作，<br>所以我们可以基于这个，对__new__方法做一些手脚，实现单例模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;基于__new__方法一&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __new__(cls):</span><br><span class="line">        # 这个函数是判断指定对象中是否有某属性，内部实现是调用了getattr()，并捕获AttributeError异常。</span><br><span class="line">        # 利用反射看看这个类有没有instance属性</span><br><span class="line">        if not hasattr(cls, &#39;instance&#39;):</span><br><span class="line">            # 调用 __new__ 方法申请内存</span><br><span class="line">            # 如果不重写 __new__ 方法，会调用 object 的 __new__方法申请内存</span><br><span class="line">            # 如果重写了 __new__ 方法，需要自己手动的申请内存</span><br><span class="line">            cls.instance &#x3D; super(Foo, cls).__new__(cls)</span><br><span class="line">        return cls.instance</span><br></pre></td></tr></table></figure>

<p><strong>什么是反射？</strong><br>在面向对象的思想中，把对象能够访问、查询、修改自身的状态或行为称为“反射”。</p>
<p><strong>python中的反射</strong><br>在python中，可以通过字符串的的形式来操作对象的属性。这种行为称之为python中的反射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============基于__new__方法二=============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 定义一个类属性，用来保存实例化的对象</span></span><br><span class="line">    <span class="comment"># 私有类属性</span></span><br><span class="line">    __instance = <span class="literal">None</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 1.判断类属性是否为空</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 2.调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.__instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">            print(cls.__instance)</span><br><span class="line">        <span class="comment"># 3.返回类属性保存的对象的应用</span></span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br></pre></td></tr></table></figure>

<h3 id="3-使用类方法"><a href="#3-使用类方法" class="headerlink" title="3.使用类方法"></a>3.使用类方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路就是,调用类的instance方法,这样有一个弊端就是在使用类创建的时候,并不是单例了.也就是说在创建类的时候一定要用类里面规定的方法创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 利用反射 看看这个类有没有_instance属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line">s1 = Singleton()  <span class="comment"># 这样创建的对象并不是单例</span></span><br><span class="line">s2 = Singleton.get_instance() <span class="comment"># 要调用特定的方法创建单例对象</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使用装饰器-推荐使用"><a href="#4-使用装饰器-推荐使用" class="headerlink" title="4.使用装饰器(推荐使用)"></a>4.使用装饰器(推荐使用)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============函数装饰器=============</span></span><br><span class="line"><span class="comment"># 1.把类当成函数传递给装饰器</span></span><br><span class="line"><span class="comment"># 2.创建类的实例的时候调用Foo已经变成了调用inner。</span></span><br><span class="line"><span class="comment"># 3.在inner内部实现单例类的创建</span></span><br><span class="line"><span class="comment"># 4.因此foo1、foo2的值都等于inner返回值。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">fun</span>):</span></span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">if</span> fun <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            <span class="comment"># 使用不可变的类地址作为键，其实例作为值，</span></span><br><span class="line">            <span class="comment"># 每次创造实例时，首先查看该类是否存在实例，</span></span><br><span class="line">            <span class="comment"># 存在的话直接返回该实例即可，</span></span><br><span class="line">            <span class="comment"># 否则新建一个实例并存放在字典中。</span></span><br><span class="line">            _instance[fun] = fun()</span><br><span class="line">        <span class="keyword">return</span> _instance[fun]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(foo1 <span class="keyword">is</span> foo2)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===========类装饰器============</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        self.cls = cls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            Singleton._instance = self.cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="comment"># Demo已经变了，Demo已经是Singleton的实例了，在Singleton里面加入了__call__方法，让实例可以被调用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">do1 = Demo()</span><br><span class="line">do2 = Demo()</span><br><span class="line">print(<span class="built_in">id</span>(do1), <span class="built_in">id</span>(do2))</span><br></pre></td></tr></table></figure>

<h3 id="5-共享属性（不推荐使用）"><a href="#5-共享属性（不推荐使用）" class="headerlink" title="5.共享属性（不推荐使用）"></a>5.共享属性（不推荐使用）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)  </span></span><br><span class="line"><span class="comment">#同一个类的所有实例天然拥有相同的行为(方法),  </span></span><br><span class="line"><span class="comment">#只需要保证同一个类的所有实例具有相同的状态(属性)即可  </span></span><br><span class="line"><span class="comment">#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        ob = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span>(<span class="params">Singleton</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;最后的结果是<span class="subst">&#123;self.name&#125;</span>&#x27;</span>) <span class="comment"># 实例化N个对象打印的都是最后创建的对象的name属性</span></span><br></pre></td></tr></table></figure>

<h3 id="6-基于metaclass-元类-实现的单例模式"><a href="#6-基于metaclass-元类-实现的单例模式" class="headerlink" title="6.基于metaclass(元类)实现的单例模式"></a>6.基于metaclass(元类)实现的单例模式</h3><p><strong>什么是元类？</strong><br>实例对象是由类来创建，那么类又是由什么来创建的呢？ 答案就是元类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            cls._instance = <span class="built_in">super</span>(SingletonType, cls).__call__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)</span></span><br><span class="line"><span class="comment"># metaclass=SingletonType 这样就表示调用SingletonType的__call__方法来创建Foo类</span></span><br><span class="line"><span class="comment"># 判断实例化的对象是否有_instance这个属性</span></span><br><span class="line"><span class="comment"># 然后调用父类type的__call__方法创建Foo对象(类)</span></span><br><span class="line"><span class="comment"># 同时Foo创建了就会调用Foo类的__new__方法和__init__方法实例化对象</span></span><br><span class="line"><span class="comment"># 返回这个实例化对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonType</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Foo(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">obj2 = Foo(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line">print(obj1, obj2)</span><br><span class="line">print(<span class="built_in">id</span>(obj1), <span class="built_in">id</span>(obj2))</span><br></pre></td></tr></table></figure>

<p>元类实现单例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonMeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">cls,*args, **kwargs</span>):</span></span><br><span class="line">    <span class="comment"># 这个self是指定了使用SingletonMeta作为元类的类对应的对象</span></span><br><span class="line">    	<span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        cls.__instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了metaclass=type的话，就会实现单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">President</span>(<span class="params"><span class="built_in">object</span>, metaclass=<span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">President() <span class="comment"># 这个类是SingletonMeta创建出的对象，那么在类后面加()，相当于调用了元类(type)的__call__魔术方法。所以可以在__call__里面做文章，来实现单例。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了metaclass=type的话，就会实现单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=SingletonMeta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://actionou.github.io/2019/12/02/python-singleton/" data-id="cki7oho2g0008m6st6xsa80cq" data-title="Python中的单例模式" class="article-share-link">Share</a>
      
      
        <a href="/2019/12/02/python-singleton/#comments" class="article-comment-link">
          <span class="post-comments-count valine-comment-count" data-xid="/2019/12/02/python-singleton/" itemprop="commentCount"></span>
          Comments
        </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/01/10/great-python-code-structure/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          写出优雅的Python代码之—仓库结构（译）
        
      </div>
    </a>
  
  
    <a href="/2019/07/01/vimrc/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">vimrc</div>
    </a>
  
</nav>

  
</article>



  <section id="comments" class="vcomment">

  </section>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pandas/" rel="tag">pandas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/" rel="tag">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/02/use-data-analysis-solve-practical-problems/">如何用数据分析思维解决实际问题？</a>
          </li>
        
          <li>
            <a href="/2020/05/03/python-pandas/">玩转Pandas数据处理</a>
          </li>
        
          <li>
            <a href="/2020/01/10/great-python-code-structure/">写出优雅的Python代码之—仓库结构（译）</a>
          </li>
        
          <li>
            <a href="/2019/12/02/python-singleton/">Python中的单例模式</a>
          </li>
        
          <li>
            <a href="/2019/07/01/vimrc/">vimrc</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2020 actionou<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = 'false' == true;
    var verify = 'false' == true;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "SWLpR8olgGKTGIX33ACCGr1d-gzGzoHsz",
        appKey: "bYikAPbAHWRxsxa7bv4S6cux",
        placeholder: "Just go go",
        pageSize:'10',
        avatar:'mm',
        lang:'zh-cn'
    });
</script>

  </div>
</body>
</html>